<body onunload=exit()><form method="POST">  <p align="center"><i><font size="3">Difference Analysis Generated by   <a href="http://www.ComponentSoftware.com/products/htmldiff" target="_blank">HtmlDiff</a> on  6/3/2003 11:47 AM</font></i>&nbsp;&nbsp;
  <input type="button" value="Navigate Changes" name="Navigate" onclick=pop_navigate()></p></form></body> <p align="left"><font size="4"><b>Base file: C:\Development\jts1.2\src\com\vividsolutions\jts\geom\LineSegment.java</b></font></p> <p align="left"><font size="4"><b>Modified file: C:\Development\jts1.3\src\com\vividsolutions\jts\geom\LineSegment.java</b></font></p><html>
<style type="text/css">
<!--
.HDNormal {  color: #000000;background:  #ffffff;text-decoration:none}
.HDDeleted {  color: #ff0000;background:  #ffffff;text-decoration:line-through}
.HDAdded {  color: #000000;background:  #ffff00;text-decoration:none}
-->
</style>
<body class="HDNormal">
<pre><a name="diff" id="c0"><span class="HDAdded">1:  
2:  
</span></a>1:  /*
2:   * The <a name="diff" id="c1"><span class="HDDeleted">Java </span></a><span class="HDAdded">JTS </span>Topology Suite<span class="HDDeleted"> (JTS)</span> is a collection of Java classes that
3:   * implement the fundamental operations required to validate a given
4:   * geo-spatial data set to a known topological specification.
5:   *
6:   * Copyright (C) 2001 Vivid Solutions
7:   *
8:   * This library is free software; you can redistribute it and/or
9:   * modify it under the terms of the GNU Lesser General Public
10:  * License as published by the Free Software Foundation; either
11:  * version 2.1 of the License, or (at your option) any later version.
12:  *
13:  * This library is distributed in the hope that it will be useful,
14:  * but WITHOUT ANY WARRANTY; without even the implied warranty of
15:  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
16:  * Lesser General Public License for more details.
17:  *
18:  * You should have received a copy of the GNU Lesser General Public
19:  * License along with this library; if not, write to the Free Software
20:  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
21:  *
22:  * For more information, contact:
23:  *
24:  *     Vivid Solutions
25:  *     Suite #1A
26:  *     2328 Government Street
27:  *     Victoria BC  V8T 5G5
28:  *     Canada
29:  *
30:  *     (250)385-6040
31:  *     www.vividsolutions.com
32:  */
33: package com.vividsolutions.jts.geom;
34: 
<a name="diff" id="c2"><span class="HDAdded">37: import java.io.Serializable;
38: 
</span></a>35: import com.vividsolutions.jts.algorithm.CGAlgorithms;
<a name="diff" id="c3"><span class="HDDeleted">36: import com.vividsolutions.jts.geom.Coordinate;
</span></a>37: 
38: /**
39:  * A &lt;code&gt;LineSegment&lt;/code&gt; represents a two-point line
40:  *@version 1.<a name="diff" id="c4"><span class="HDDeleted">2</span></a><span class="HDAdded">3</span>
41:  */
42: 
43: public class LineSegment
44:   implements Comparable<a name="diff" id="c5"><span class="HDAdded">, Serializable</span></a>
45: {
46: 
47:   public Coordinate p0, p1;
48: 
49:   public LineSegment(Coordinate p0, Coordinate p1) {
50:     this.p0 = p0;
51:     this.p1 = p1;
52:   }
53: 
54:   public LineSegment(LineSegment ls) {
55:     this(ls.p0, ls.p1);
56:   }
57: 
58:   public LineSegment() {
59:     this(new Coordinate(), new Coordinate());
60:   }
61: 
62:   public Coordinate getCoordinate(int i)
63:   {
64:     if (i == 0) return p0;
65:     return p1;
66:   }
67: 
68:   public void setCoordinates(LineSegment ls)
69:   {
70:     setCoordinates(ls.p0, ls.p1);
71:   }
72: 
73:   public void setCoordinates(Coordinate p0, Coordinate p1)
74:   {
75:     this.p0.x = p0.x;
76:     this.p0.y = p0.y;
77:     this.p1.x = p1.x;
78:     this.p1.y = p1.y;
79:   }
80: 
81:   /**
82:    * Computes the length of the line segment.
83:    * @return the length of the line segment
84:    */
85:   public double getLength()
86:   {
87:     return p0.distance(p1);
88:   }
89: 
90:   /**
91:    * Reverses the direction of the line segment.
92:    */
93:   public void reverse()
94:   {
95:     Coordinate temp = p0;
96:     p0 = p1;
97:     p1 = temp;
98:   }
99:   /**
100:       * Puts the line segment into a normalized form.
101:       * This is useful for using line segments in maps and indexes when
102:       * topological equality rather than exact equality is desired.
103:       */
104:      public void normalize()
105:      {
106:        if (p1.compareTo(p0) &lt; 0) reverse();
107:      }
108:    
109:      /**
110:       * @return the angle this segment makes with the x-axis (in radians)
111:       */
112:      public double angle()
113:      {
114:        return Math.atan2(p1.y - p0.y, p1.x - p0.x);
115:      }
116:    
117:      /**
118:       * Computes the distance between this line segment and another one.
119:       */
120:      public double distance(LineSegment ls)
121:      {
122:        return CGAlgorithms.distanceLineLine(p0, p1, ls.p0, ls.p1);
123:      }
124:    
125:      /**
126:       * Computes the distance between this line segment and another one.
127:       */
128:      public double distance(Coordinate p)
129:      {
130:        return CGAlgorithms.distancePointLine(p, p0, p1);
131:      }
132:    
133:      /**
134:       * Compute the projection factor for the projection of the point p
135:       * onto this LineSegment.  The projection factor is the constant k
136:       * by which the vector for this segment must be multiplied to
137:       * equal the vector for the projection of p.
138:       */
139:      public double projectionFactor(Coordinate p)
140:      {
141:        if (p.equals(p0)) return 0.0;
142:        if (p.equals(p1)) return 1.0;
143:        // Otherwise, use comp.graphics.algorithms Frequently Asked Questions method
144:        /*            AC dot AB
145:                       r = ---------
146:                             ||AB||^2
147:                    r has the following meaning:
148:                    r=0 P = A
149:                    r=1 P = B
150:                    r&lt;0 P is on the backward extension of AB
151:                    r&gt;1 P is on the forward extension of AB
152:                    0&lt;r&lt;1 P is interior to AB
153:            */
154:        double dx = p1.x - p0.x;
155:        double dy = p1.y - p0.y;
156:        double len2 = dx * dx + dy * dy;
157:        double r = ( (p.x - p0.x) * dx + (p.y - p0.y) * dy )
158:                  / len2;
159:        return r;
160:      }
161:    
162:      /**
163:       * Compute the projection of a point onto the line determined
164:       * by this line segment.
165:       * &lt;p&gt;
166:       * Note that the projected point
167:       * may lie outside the line segment.  If this is the case,
168:       * the projection factor will lie outside the range [0.0, 1.0].
169:       */
170:      public Coordinate project(Coordinate p)
171:      {
172:        if (p.equals(p0) || p.equals(p1)) return new Coordinate(p);
173:    
174:        double r = projectionFactor(p);
175:        Coordinate coord = new Coordinate();
176:        coord.x = p0.x + r * (p1.x - p0.x);
177:        coord.y = p0.y + r * (p1.y - p0.y);
178:        return coord;
179:      }
180:      /**
181:       * Project a line segment onto this line segment and return the resulting
182:       * line segment.  The returned line segment will be a subset of
183:       * the target line line segment.  This subset may be null, if
184:       * the segments are oriented in such a way that there is no projection.
185:       * &lt;p&gt;
186:       * Note that the returned line may have zero length (i.e. the same endpoints).
187:       * This can happen for instance if the lines are perpendicular to one another.
188:       *
189:       * @param seg the line segment to project
190:       * @return the projected line segment, or &lt;code&gt;null&lt;/code&gt; if there is no overlap
191:       */
192:      public LineSegment project(LineSegment seg)
193:      {
194:        double pf0 = projectionFactor(seg.p0);
195:        double pf1 = projectionFactor(seg.p1);
196:        // check if segment projects at all
197:        if (pf0 &gt;= 1.0 &amp;&amp; pf1 &gt;= 1.0) return null;
198:        if (pf0 &lt;= 0.0 &amp;&amp; pf1 &lt;= 0.0) return null;
199:    
200:        Coordinate newp0 = project(seg.p0);
201:        if (pf0 &lt; 0.0) newp0 = p0;
202:        if (pf0 &gt; 1.0) newp0 = p1;
203:    
204:        Coordinate newp1 = project(seg.p1);
205:        if (pf1 &lt; 0.0) newp1 = p0;
206:        if (pf1 &gt; 1.0) newp1 = p1;
207:    
208:        return new LineSegment(newp0, newp1);
209:      }
210:      /**
211:       * Computes the closest point on this line segment to another point.
212:       * @param p the point to find the closest point to
213:       * @return a Coordinate which is the closest point on the line segment to the point p
214:       */
215:      public Coordinate closestPoint(Coordinate p)
216:      {
217:        double factor = projectionFactor(p);
218:        if (factor &gt; 0 &amp;&amp; factor &lt; 1) {
219:          return project(p);
220:        }
221:        double dist0 = p0.distance(p);
222:        double dist1 = p1.distance(p);
223:        if (dist0 &lt; dist1)
224:          return p0;
225:        return p1;
226:      }
227:      /**
228:       *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;other&lt;/code&gt; has the same values for
229:       *  its points.
230:       *
231:       *@param  other  a &lt;code&gt;LineSegment&lt;/code&gt; with which to do the comparison.
232:       *@return        &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;other&lt;/code&gt; is a &lt;code&gt;LineSegment&lt;/code&gt;
233:       *      with the same values for the x and y ordinates.
234:       */
235:      public boolean equals(Object o) {
236:        if (!(o instanceof LineSegment)) {
237:          return false;
238:        }
239:        LineSegment other = (LineSegment) o;
240:        return p0.equals(other.p0) &amp;&amp; p1.equals(other.p1);
241:      }
242:    
243:    
244:      /**
245:       *  Compares this object with the specified object for order.
246:       *  Uses the standard lexicographic ordering for the points in the LineSegment.
247:       *
248:       *@param  o  the &lt;code&gt;LineSegment&lt;/code&gt; with which this &lt;code&gt;LineSegment&lt;/code&gt;
249:       *      is being compared
250:       *@return    a negative integer, zero, or a positive integer as this &lt;code&gt;LineSegment&lt;/code&gt;
251:       *      is less than, equal to, or greater than the specified &lt;code&gt;LineSegment&lt;/code&gt;
252:       */
253:      public int compareTo(Object o) {
254:        LineSegment other = (LineSegment) o;
255:        int comp0 = p0.compareTo(other.p0);
256:        if (comp0 != 0) return comp0;
257:        return p1.compareTo(other.p1);
258:      }
259:    
260:      /**
261:       *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;other&lt;/code&gt; is
262:       *  topologically equal to this LineSegment (e.g. irrespective
263:       *  of orientation).
264:       *
265:       *@param  other  a &lt;code&gt;LineSegment&lt;/code&gt; with which to do the comparison.
266:       *@return        &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;other&lt;/code&gt; is a &lt;code&gt;LineSegment&lt;/code&gt;
267:       *      with the same values for the x and y ordinates.
268:       */
269:      public boolean equalsTopo(LineSegment other)
270:      {
271:        return
272:          p0.equals(other.p0) &amp;&amp; p1.equals(other.p1)
273:          || p0.equals(other.p1) &amp;&amp; p1.equals(other.p0);
274:      }
275:    
276:      public String toString()
277:      {
278:        return "LINESTRING( " +
279:            p0.x + " " + p0.y
280:            + ", " +
281:            p1.x + " " + p1.y + ")";
282:      }
283:    }</pre>
</body>
<SCRIPT LANGUAGE="JavaScript" TYPE="text/javascript">
<!--
var newWind;
function putJumpCode(){
	var cnt = 6;
	newWind.document.write('<html>\n');
	newWind.document.write('<title>HtmlDiff Navigation</title>\n');
	newWind.document.write('<body>\n');
	newWind.document.write('<form name="jump">\n');
	newWind.document.write('<input type="button" value=" |&lt; " name="First" onclick=goto_first(this.form)>&nbsp;')
	newWind.document.write('<input type="button" value=" &lt; " name="Prev" onclick=goto_prev(this.form)>&nbsp;&nbsp;\n');
	newWind.document.write('<select name=url onchange=menu_goto(this.form)> \n');
	for (var i=0; i<cnt ;i++ ) {
		newWind.document.write('<option value="#C'+i+'">Change #'+(i+1)+ '</option> \n');
		}
	newWind.document.write('');
	newWind.document.write('</select>&nbsp;&nbsp;\n');
	newWind.document.write('<input type="button" value=" &gt; " name="Next"\n');
	newWind.document.write('onclick=goto_next(this.form)>\n');
	newWind.document.write('<input type="button" value=" &gt| " name="Last"\n');
	newWind.document.write('onclick=goto_last(this.form)>\n');
	newWind.document.write('</form>\n');
	newWind.document.write('');
	newWind.document.write('<form method="POST">\n');
	newWind.document.write('<p align="center"><i><font size="3">Generated\n');
	newWind.document.write('by <a href="http://www.ComponentSoftware.com/products/htmldiff" target="_blank">HtmlDiff</a> \n');
	newWind.document.write('</form>\n');
	newWind.document.write('</body>\n');
	newWind.document.write('</html>\n');
	newWind.document.write('<SCRIPT LANGUAGE="JavaScript" TYPE="text/javascript">\n');
	newWind.document.write('<!--\n');
	newWind.document.write('');
	newWind.document.write('var directCloseFlag=1;\n');
	newWind.document.write('');
	newWind.document.write('function menu_goto( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('  var baseurl = opener.location.href ;\n');
	newWind.document.write('  var idx = baseurl.indexOf("#");\n');
	newWind.document.write('  if (idx > -1) {\n');
	newWind.document.write('	baseurl = baseurl.slice(0, idx);\n');
	newWind.document.write('  }');
	newWind.document.write('  selecteditem = menuform.url.selectedIndex ;\n');
	newWind.document.write('  newurl = menuform.url.options[ selecteditem ].value ;\n');
	newWind.document.write('  if (newurl.length != 0) {\n');
	newWind.document.write('    	opener.top.location.href = baseurl + newurl ;\n');
	newWind.document.write('  }');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_prev( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	if(menuform.url.selectedIndex>0) menuform.url.selectedIndex--;\n');
	newWind.document.write('	menu_goto( menuform )\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_first( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	menuform.url.selectedIndex = 0;	\n');
	newWind.document.write('	menu_goto( menuform );\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_last( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	menuform.url.selectedIndex = menuform.url.options.length-1;	\n');
	newWind.document.write('	menu_goto( menuform );\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_next( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	if(menuform.url.options.length > (menuform.url.selectedIndex+1))\n');
	newWind.document.write('	menuform.url.selectedIndex++;\n');
	newWind.document.write('	menu_goto( menuform )\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function restore()\n');
	newWind.document.write('{\n');
	newWind.document.write('    	focus();\n');
	newWind.document.write('	menu_goto(jump);\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('goto_first(jump)\n');
	newWind.document.write('//-->\n');
	newWind.document.write('<');
	newWind.document.write('/SCRIPT>\n');
}
function pop_navigate(){
  if ((newWind==null)||(newWind.closed)) {
    newWind =  window.open("" ,"HtmlDiffJumpWindow","width=270,height=40")
    if (newWind.opener == null) { // for Nav 2.0x
      newWind.opener = self // this creates and sets a new prop
    }	putJumpCode();
  
} 
else 
{	newWind.execScript("restore()", "JavaScript");
  }
}
function exit(){
  if (newWind != null) {   
	newWind.close();
  }
}
//--></SCRIPT></html>
