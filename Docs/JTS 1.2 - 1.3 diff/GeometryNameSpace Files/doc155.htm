<body onunload=exit()><form method="POST">  <p align="center"><i><font size="3">Difference Analysis Generated by   <a href="http://www.ComponentSoftware.com/products/htmldiff" target="_blank">HtmlDiff</a> on  6/3/2003 11:47 AM</font></i>&nbsp;&nbsp;
  <input type="button" value="Navigate Changes" name="Navigate" onclick=pop_navigate()></p></form></body> <p align="left"><font size="4"><b>Base file: C:\Development\jts1.2\src\com\vividsolutions\jts\geom\LineString.java</b></font></p> <p align="left"><font size="4"><b>Modified file: C:\Development\jts1.3\src\com\vividsolutions\jts\geom\LineString.java</b></font></p><html>
<style type="text/css">
<!--
.HDNormal {  color: #000000;background:  #ffffff;text-decoration:none}
.HDDeleted {  color: #ff0000;background:  #ffffff;text-decoration:line-through}
.HDAdded {  color: #000000;background:  #ffff00;text-decoration:none}
-->
</style>
<body class="HDNormal">
<pre><a name="diff" id="c0"><span class="HDAdded">1:  
2:  
</span></a>1:  /*
2:   * <a name="diff" id="c1"><span class="HDDeleted"> </span></a>The <span class="HDDeleted">Java </span><span class="HDAdded">JTS </span>Topology Suite<span class="HDDeleted"> (JTS)</span> is a collection of Java classes that
3:   *  implement the fundamental operations required to validate a given
4:   *  geo-spatial data set to a known topological specification.
5:   *
6:   *  Copyright (C) 2001 Vivid Solutions
7:   *
8:   *  This library is free software; you can redistribute it and/or
9:   *  modify it under the terms of the GNU Lesser General Public
10:  *  License as published by the Free Software Foundation; either
11:  *  version 2.1 of the License, or (at your option) any later version.
12:  *
13:  *  This library is distributed in the hope that it will be useful,
14:  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
15:  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
16:  *  Lesser General Public License for more details.
17:  *
18:  *  You should have received a copy of the GNU Lesser General Public
19:  *  License along with this library; if not, write to the Free Software
20:  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
21:  *
22:  *  For more information, contact:
23:  *
24:  *  Vivid Solutions
25:  *  Suite #1A
26:  *  2328 Government Street
27:  *  Victoria BC  V8T 5G5
28:  *  Canada
29:  *
30:  *  (250)385-6040
31:  *  www.vividsolutions.com
32:  */
33: package com.vividsolutions.jts.geom;
34: 
<a name="diff" id="c2"><span class="HDAdded">37: import com.vividsolutions.jts.algorithm.CGAlgorithms;
</span></a>35: import com.vividsolutions.jts.geom.sfs.SFSLineString;
<a name="diff" id="c3"><span class="HDDeleted">36: import java.util.ArrayList;
37: import java.util.Arrays;
</span></a>38: import com.vividsolutions.jts.operation.IsSimpleOp;
<a name="diff" id="c4"><span class="HDDeleted">39: import com.vividsolutions.jts.algorithm.CGAlgorithms;
</span></a>40: 
41: /**
42:  *  Basic implementation of &lt;code&gt;LineString&lt;/code&gt;.
43:  *
44:  *@version 1.<a name="diff" id="c5"><span class="HDDeleted">2</span></a><span class="HDAdded">3</span>
45:  */
46: public class LineString extends Geometry implements SFSLineString {
47: 
48:   /**
49:    *  The points of this &lt;code&gt;LineString&lt;/code&gt;.
50:    */
51:   protected Coordinate points[];
52: 
53:   /**
54:    *  Constructs a &lt;code&gt;LineString&lt;/code&gt; with the given points.
55:    *
56:    *@param  points          the points of the linestring, or &lt;code&gt;null&lt;/code&gt;
57:    *      to create the empty geometry. This array must not contain &lt;code&gt;null&lt;/code&gt;
58:    *      elements. Consecutive points may not be equal.
59:    *@param  precisionModel  the specification of the grid of allowable points
60:    *      for this &lt;code&gt;LineString&lt;/code&gt;
61:    *@param  SRID            the ID of the Spatial Reference System used by this
62:    *      &lt;code&gt;LineString&lt;/code&gt;
63:    */
64:   public LineString(Coordinate points[], PrecisionModel precisionModel, int SRID) {
65:     super(precisionModel, SRID);
66:     if (points == null) {
67:       points = new Coordinate[]{};
68:     }
69:     if (hasNullElements(points)) {
70:       throw new IllegalArgumentException("point array must not contain null elements");
71:     }
72:     if (points.length == 1) {
73:       throw new IllegalArgumentException("point array must contain 0 or &gt;1 elements");
74:     }
75:     this.points = points;
76:   }
77: 
78:   public Coordinate[] getCoordinates() {
79:     return points;
80:   }
81: 
82:   public Coordinate getCoordinateN(int n) {
83:     return points[n];
84:   }
85: 
86:   public Coordinate getCoordinate()
87:   {
88:     if (isEmpty()) return null;
89:     return points[0];
90:   }
91: 
92:   public int getDimension() {
93:     return 1;
94:   }
95: 
96:   public int getBoundaryDimension() {
97:     if (isClosed()) {
98:       return Dimension.FALSE;
99:     }
100:        return 0;
101:      }
102:    
103:      public boolean isEmpty() {
104:        return points.length == 0;
105:      }
106:    
107:      public int getNumPoints() {
108:        return points.length;
109:      }
110:    
111:      public Point getPointN(int n) {
112:        return new Point(points[n], getPrecisionModel(), SRID);
113:      }
114:    
115:      public Point getStartPoint() {
116:        if (isEmpty()) {
117:          return null;
118:        }
119:        return getPointN(0);
120:      }
121:    
122:      public Point getEndPoint() {
123:        if (isEmpty()) {
124:          return null;
125:        }
126:        return getPointN(getNumPoints() - 1);
127:      }
128:    
129:      public boolean isClosed() {
130:        if (isEmpty()) {
131:          return false;
132:        }
133:        return getCoordinateN(0).equals2D(getCoordinateN(getNumPoints() - 1));
134:      }
135:    
136:      public boolean isRing() {
137:        return isClosed() &amp;&amp; isSimple();
138:      }
139:    
140:      public String getGeometryType() {
141:        return "LineString";
142:      }
143:    
144:      /**
145:       *  Returns the length of this &lt;code&gt;LineString&lt;/code&gt;
146:       *
147:       *@return the area of the polygon
148:       */
149:      public double getLength()
150:      {
151:       return CGAlgorithms.length(points);
152:      }
153:    
154:      public boolean isSimple()
155:      {
156:        return (new IsSimpleOp()).isSimple(this);
157:      }
158:    
159:      public Geometry getBoundary() {
160:        if (isEmpty()) {
161:          return new GeometryCollection(null, precisionModel, SRID);
162:        }
163:        if (isClosed()) {
164:          return new MultiPoint(null, precisionModel, SRID);
165:        }
166:        return new MultiPoint(new Point[]{
167:            getStartPoint(), getEndPoint()
168:            }, precisionModel, SRID);
169:      }
170:    
171:    
172:      /**
173:       *  Returns true if the given point is a vertex of this &lt;code&gt;LineString&lt;/code&gt;
174:       *  .
175:       *
176:       *@param  pt  the &lt;code&gt;Coordinate&lt;/code&gt; to check
177:       *@return     &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;pt&lt;/code&gt; is one of this &lt;code&gt;LineString&lt;/code&gt;
178:       *      's vertices
179:       */
180:      public boolean isCoordinate(Coordinate pt) {
181:        for (int i = 1; i &lt; points.length; i++) {
182:          if (points[i].equals(pt)) {
183:            return true;
184:          }
185:        }
186:        return false;
187:      }
188:    
189:      protected Envelope computeEnvelopeInternal() {
190:        if (isEmpty()) {
191:          return new Envelope();
192:        }
193:        double minx = points[0].x;
194:        double miny = points[0].y;
195:        double maxx = points[0].x;
196:        double maxy = points[0].y;
197:        for (int i = 1; i &lt; points.length; i++) {
198:          minx = Math.min(minx, points[i].x);
199:          maxx = Math.max(maxx, points[i].x);
200:          miny = Math.min(miny, points[i].y);
201:          maxy = Math.max(maxy, points[i].y);
202:        }
203:        return new Envelope(minx, maxx, miny, maxy);
204:      }
205:    
206:      public boolean equalsExact(Geometry other<a name="diff" id="c6"><span class="HDAdded">, double tolerance</span></a>) {
207:        if (!isEquivalentClass(other)) {
208:          return false;
209:        }
210:        LineString otherLineString = (LineString) other;
211:        if (points.length != otherLineString.points.length) {
212:          return false;
213:        }
214:        for (int i = 0; i &lt; points.length; i++) {
215:          if (!<a name="diff" id="c7"><span class="HDAdded">equal(</span></a>points[i]<span class="HDDeleted">.equals(</span><span class="HDAdded">, </span>otherLineString.points[i]<span class="HDAdded">, tolerance</span>)) {
216:            return false;
217:          }
218:        }
219:        return true;
220:      }
221:    
222:      public void apply(CoordinateFilter filter) {
223:        for (int i = 0; i &lt; points.length; i++) {
224:          filter.filter(points[i]);
225:        }
226:      }
227:    
228:      public void apply(GeometryFilter filter) {
229:        filter.filter(this);
230:      }
231:    
232:      public void apply(GeometryComponentFilter filter) {
233:        filter.filter(this);
234:      }
235:    
236:      public Object clone() {
237:        LineString ls = (LineString) super.clone();
238:        Coordinate[] pts = new Coordinate[points.length];
239:        ls.points = pts;
240:        for (int i = 0; i &lt; points.length; i++) {
241:          ls.points[i] = (Coordinate) points[i].clone();
242:        }
243:        return ls;// return the clone
244:      }
245:    
<a name="diff" id="c8"><span class="HDAdded">246:    </span></a><span class="HDAdded">  /**
</span><span class="HDAdded">247:    </span><span class="HDAdded">   * Normalizes a LineString.  A normalized linestring
</span><span class="HDAdded">248:    </span><span class="HDAdded">   * has the first point which is not equal to it's reflected point
</span><span class="HDAdded">249:    </span><span class="HDAdded">   * less than the reflected point.
</span><span class="HDAdded">250:    </span><span class="HDAdded">   */
</span>251:      public void normalize()<span class="HDDeleted"> {</span>
<span class="HDDeleted">252:    </span><span class="HDDeleted">    for (int i = 0; i &lt; points.length; i++) {
</span><span class="HDAdded">253:    </span><span class="HDAdded">  {
</span><span class="HDAdded">254:    </span><span class="HDAdded">    for (int i = 0; i &lt; points.length / 2; i++) {
</span>255:          int j = points.length - 1 - i;
<a name="diff" id="c9"><span class="HDAdded">255:          // skip equal points on both ends
</span></a>256:          if (!points[i].equals(points[j])) {
257:            if (points[i].compareTo(points[j]) &gt; 0) {
258:              <a name="diff" id="c10"><span class="HDAdded">CoordinateArrays.</span></a>reverse<span class="HDDeleted">PointOrder</span>(points);
259:            }
260:            return;
261:          }
262:        }
263:      }
264:    
265:      protected boolean isEquivalentClass(Geometry other) {
266:        return other instanceof LineString;
267:      }
268:    
269:      protected int compareToSameClass(Object o)<a name="diff" id="c11"><span class="HDDeleted"> {</span></a>
<span class="HDAdded">270:      {
271:        LineString line = (LineString) o;
272:        // MD - optimized implementation
273:        int i = 0;
274:        int j = 0;
275:        while (i &lt; points.length &amp;&amp; j &lt; line.points.length) {
276:          int comparison = points[i].compareTo(line.points[j]);
277:          if (comparison != 0) {
278:            return comparison;
279:          }
280:          i++;
281:          j++;
282:        }
283:        if (i &lt; points.length) {
284:          return 1;
285:        }
286:        if (j &lt; line.points.length) {
287:          return -1;
288:        }
289:        return 0;
290:    
291:        /*
</span>270:        ArrayList theseElements = new ArrayList(Arrays.asList(points));
271:        ArrayList otherElements = new ArrayList(Arrays.asList(((LineString) o).points));
272:        return compare(theseElements, otherElements);
<a name="diff" id="c12"><span class="HDAdded">295:        */
</span></a>273:      }
274:    
275:    }
276:    
</pre>
</body>
<SCRIPT LANGUAGE="JavaScript" TYPE="text/javascript">
<!--
var newWind;
function putJumpCode(){
	var cnt = 13;
	newWind.document.write('<html>\n');
	newWind.document.write('<title>HtmlDiff Navigation</title>\n');
	newWind.document.write('<body>\n');
	newWind.document.write('<form name="jump">\n');
	newWind.document.write('<input type="button" value=" |&lt; " name="First" onclick=goto_first(this.form)>&nbsp;')
	newWind.document.write('<input type="button" value=" &lt; " name="Prev" onclick=goto_prev(this.form)>&nbsp;&nbsp;\n');
	newWind.document.write('<select name=url onchange=menu_goto(this.form)> \n');
	for (var i=0; i<cnt ;i++ ) {
		newWind.document.write('<option value="#C'+i+'">Change #'+(i+1)+ '</option> \n');
		}
	newWind.document.write('');
	newWind.document.write('</select>&nbsp;&nbsp;\n');
	newWind.document.write('<input type="button" value=" &gt; " name="Next"\n');
	newWind.document.write('onclick=goto_next(this.form)>\n');
	newWind.document.write('<input type="button" value=" &gt| " name="Last"\n');
	newWind.document.write('onclick=goto_last(this.form)>\n');
	newWind.document.write('</form>\n');
	newWind.document.write('');
	newWind.document.write('<form method="POST">\n');
	newWind.document.write('<p align="center"><i><font size="3">Generated\n');
	newWind.document.write('by <a href="http://www.ComponentSoftware.com/products/htmldiff" target="_blank">HtmlDiff</a> \n');
	newWind.document.write('</form>\n');
	newWind.document.write('</body>\n');
	newWind.document.write('</html>\n');
	newWind.document.write('<SCRIPT LANGUAGE="JavaScript" TYPE="text/javascript">\n');
	newWind.document.write('<!--\n');
	newWind.document.write('');
	newWind.document.write('var directCloseFlag=1;\n');
	newWind.document.write('');
	newWind.document.write('function menu_goto( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('  var baseurl = opener.location.href ;\n');
	newWind.document.write('  var idx = baseurl.indexOf("#");\n');
	newWind.document.write('  if (idx > -1) {\n');
	newWind.document.write('	baseurl = baseurl.slice(0, idx);\n');
	newWind.document.write('  }');
	newWind.document.write('  selecteditem = menuform.url.selectedIndex ;\n');
	newWind.document.write('  newurl = menuform.url.options[ selecteditem ].value ;\n');
	newWind.document.write('  if (newurl.length != 0) {\n');
	newWind.document.write('    	opener.top.location.href = baseurl + newurl ;\n');
	newWind.document.write('  }');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_prev( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	if(menuform.url.selectedIndex>0) menuform.url.selectedIndex--;\n');
	newWind.document.write('	menu_goto( menuform )\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_first( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	menuform.url.selectedIndex = 0;	\n');
	newWind.document.write('	menu_goto( menuform );\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_last( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	menuform.url.selectedIndex = menuform.url.options.length-1;	\n');
	newWind.document.write('	menu_goto( menuform );\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_next( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	if(menuform.url.options.length > (menuform.url.selectedIndex+1))\n');
	newWind.document.write('	menuform.url.selectedIndex++;\n');
	newWind.document.write('	menu_goto( menuform )\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function restore()\n');
	newWind.document.write('{\n');
	newWind.document.write('    	focus();\n');
	newWind.document.write('	menu_goto(jump);\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('goto_first(jump)\n');
	newWind.document.write('//-->\n');
	newWind.document.write('<');
	newWind.document.write('/SCRIPT>\n');
}
function pop_navigate(){
  if ((newWind==null)||(newWind.closed)) {
    newWind =  window.open("" ,"HtmlDiffJumpWindow","width=270,height=40")
    if (newWind.opener == null) { // for Nav 2.0x
      newWind.opener = self // this creates and sets a new prop
    }	putJumpCode();
  
} 
else 
{	newWind.execScript("restore()", "JavaScript");
  }
}
function exit(){
  if (newWind != null) {   
	newWind.close();
  }
}
//--></SCRIPT></html>
