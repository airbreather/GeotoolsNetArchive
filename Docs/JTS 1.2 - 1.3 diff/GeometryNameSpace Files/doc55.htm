<body onunload=exit()><form method="POST">  <p align="center"><i><font size="3">Difference Analysis Generated by   <a href="http://www.ComponentSoftware.com/products/htmldiff" target="_blank">HtmlDiff</a> on  6/3/2003 11:47 AM</font></i>&nbsp;&nbsp;
  <input type="button" value="Navigate Changes" name="Navigate" onclick=pop_navigate()></p></form></body> <p align="left"><font size="4"><b>Base file: C:\Development\jts1.2\src\com\vividsolutions\jts\geom\Envelope.java</b></font></p> <p align="left"><font size="4"><b>Modified file: C:\Development\jts1.3\src\com\vividsolutions\jts\geom\Envelope.java</b></font></p><html>
<style type="text/css">
<!--
.HDNormal {  color: #000000;background:  #ffffff;text-decoration:none}
.HDDeleted {  color: #ff0000;background:  #ffffff;text-decoration:line-through}
.HDAdded {  color: #000000;background:  #ffff00;text-decoration:none}
-->
</style>
<body class="HDNormal">
<pre><a name="diff" id="c0"><span class="HDAdded">1:  
2:  
</span></a>1:  /*
2:   * <a name="diff" id="c1"><span class="HDDeleted"> </span></a>The <span class="HDDeleted">Java </span><span class="HDAdded">JTS </span>Topology Suite<span class="HDDeleted"> (JTS)</span> is a collection of Java classes that
3:   *  implement the fundamental operations required to validate a given
4:   *  geo-spatial data set to a known topological specification.
5:   *
6:   *  Copyright (C) 2001 Vivid Solutions
7:   *
8:   *  This library is free software; you can redistribute it and/or
9:   *  modify it under the terms of the GNU Lesser General Public
10:  *  License as published by the Free Software Foundation; either
11:  *  version 2.1 of the License, or (at your option) any later version.
12:  *
13:  *  This library is distributed in the hope that it will be useful,
14:  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
15:  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
16:  *  Lesser General Public License for more details.
17:  *
18:  *  You should have received a copy of the GNU Lesser General Public
19:  *  License along with this library; if not, write to the Free Software
20:  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
21:  *
22:  *  For more information, contact:
23:  *
24:  *  Vivid Solutions
25:  *  Suite #1A
26:  *  2328 Government Street
27:  *  Victoria BC  V8T 5G5
28:  *  Canada
29:  *
30:  *  (250)385-6040
31:  *  www.vividsolutions.com
32:  */
33: package com.vividsolutions.jts.geom;
34: 
<a name="diff" id="c2"><span class="HDDeleted">35: </span></a><span class="HDDeleted">import com.vividsolutions.jts.util.Assert;
</span><span class="HDAdded">36: </span><span class="HDAdded">import java.io.Serializable;
</span>37: 
38: /**
39:  *  An Envelope defines a <a name="diff" id="c3"><span class="HDDeleted">rectangulare</span></a><span class="HDAdded">rectangular</span> region of the 2D coordinate plane.
40:  *  It is often used to represent the bounding box of a Geometry,
41:  *  e.g. the minimum and maximum x and y values of the Coordinates.
42:  *  &lt;p&gt;
43:  *  Note that Envelopes support infinite or half-infinite regions, by using the values of
44:  *  &lt;code&gt;Double.POSITIVE_INFINITY&lt;/code&gt; and &lt;code&gt;Double.NEGATIVE_INFINITY&lt;/code&gt;.
45:  *  &lt;p&gt;
46:  *  When Envelope objects are created or initialized,
47:  *  the supplies extent values are automatically sorted into the correct order.
48:  *
49:  *@version 1.<a name="diff" id="c4"><span class="HDDeleted">2</span></a><span class="HDAdded">3</span>
50:  */
51: public class Envelope<a name="diff" id="c5"><span class="HDDeleted"> {</span></a>
<span class="HDDeleted">52: </span><span class="HDDeleted">
</span><span class="HDAdded">53: </span><span class="HDAdded">    implements Serializable
</span><span class="HDAdded">54: {
55: 
56:   /**
57:    * Test the point q to see whether it intersects the Envelope defined by p1-p2
58:    * @param p1 one extremal point of the envelope
59:    * @param p2 another extremal point of the envelope
60:    * @param q the point to test for intersection
61:    * @return &lt;code&gt;true&lt;/code&gt; if q intersects the envelope p1-p2
62:    */
63:   public static boolean intersects(Coordinate p1, Coordinate p2, Coordinate q)
64:   {
65:     if (((q.x &gt;= Math.min(p1.x, p2.x)) &amp;&amp; (q.x &lt;= Math.max(p1.x, p2.x))) &amp;&amp;
66:         ((q.y &gt;= Math.min(p1.y, p2.y)) &amp;&amp; (q.y &lt;= Math.max(p1.y, p2.y)))) {
67:       return true;
68:     }
69:     return false;
70:   }
71:   /**
72:    * Test the envelope defined by p1-p2 for intersection
73:    * with the envelope defined by q1-q2
74:    * @param p1 one extremal point of the envelope P
75:    * @param p2 another extremal point of the envelope P
76:    * @param q1 one extremal point of the envelope Q
77:    * @param q2 another extremal point of the envelope Q
78:    * @return &lt;code&gt;true&lt;/code&gt; if Q intersects P
79:    */
80:   public static boolean intersects(Coordinate p1, Coordinate p2, Coordinate q1, Coordinate q2)
81:   {
82:     double minq = Math.min(q1.x, q2.x);
83:     double maxq = Math.max(q1.x, q2.x);
84:     double minp = Math.min(p1.x, p2.x);
85:     double maxp = Math.max(p1.x, p2.x);
86: 
87:     if( minp &gt; maxq )
88:         return false;
89:     if( maxp &lt; minq )
90:         return false;
91: 
92:     minq = Math.min(q1.y, q2.y);
93:     maxq = Math.max(q1.y, q2.y);
94:     minp = Math.min(p1.y, p2.y);
95:     maxp = Math.max(p1.y, p2.y);
96: 
97:     if( minp &gt; maxq )
98:         return false;
99:     if( maxp &lt; minq )
100:            return false;
101:        return true;
102:      }
</span>53:   /**
54:    * Compute the distance between two points specified by their ordinate values
55:    */
56:   private static double distance(double x0, double y0, double x1, double y1)
57:   {
58:     double dx = x1 - x0;
59:     double dy = y1 - y0;
60:     return Math.sqrt(dx * dx + dy * dy);
61:   }
62: 
63:   /**
64:    *  the minimum x-coordinate
65:    */
66:   private double minx;
67: 
68:   /**
69:    *  the maximum x-coordinate
70:    */
71:   private double maxx;
72: 
73:   /**
74:    *  the minimum y-coordinate
75:    */
76:   private double miny;
77: 
78:   /**
79:    *  the maximum y-coordinate
80:    */
81:   private double maxy;
82: 
83:   /**
84:    *  Creates a null &lt;code&gt;Envelope&lt;/code&gt;.
85:    */
86:   public Envelope() {
87:     init();
88:   }
89: 
90:   /**
91:    *  Creates an &lt;code&gt;Envelope&lt;/code&gt; for a region defined by maximum and minimum values.
92:    *
93:    *@param  x1  the first x-value
94:    *@param  x2  the second x-value
95:    *@param  y1  the first y-value
96:    *@param  y2  the second y-value
97:    */
98:   public Envelope(double x1, double x2, double y1, double y2)
99:   {
100:        init(x1, x2, y1, y2);
101:      }
102:    
103:      /**
104:       *  Creates an &lt;code&gt;Envelope&lt;/code&gt; for a region defined by two Coordinates.
105:       *
106:       *@param  p1  the first Coordinate
107:       *@param  p2  the second Coordinate
108:       */
109:      public Envelope(Coordinate p1, Coordinate p2)
110:      {
111:        init(p1, p2);
112:      }
113:    
114:      /**
115:       *  Creates an &lt;code&gt;Envelope&lt;/code&gt; for a region defined by a single Coordinate.
116:       *
117:       *@param  p1  the Coordinate
118:       */
119:      public Envelope(Coordinate p)
120:      {
121:        init(p);
122:      }
123:    
124:      /**
125:       *  Create an &lt;code&gt;Envelope&lt;/code&gt; from an existing Envelope.
126:       *
127:       *@param  env  the Envelope to initialize from
128:       */
129:      public Envelope(Envelope env)
130:      {
131:        init(env);
132:      }
133:    
134:      /**
135:       *  Initialize to a null &lt;code&gt;Envelope&lt;/code&gt;.
136:       */
137:      public void init()
138:      {
139:        setToNull();
140:      }
141:    
142:      /**
143:       *  Initialize an &lt;code&gt;Envelope&lt;/code&gt; for a region defined by maximum and minimum values.
144:       *
145:       *@param  x1  the first x-value
146:       *@param  x2  the second x-value
147:       *@param  y1  the first y-value
148:       *@param  y2  the second y-value
149:       */
150:      public void init(double x1, double x2, double y1, double y2)
151:      {
152:        if (x1 &lt; x2) {
153:          minx = x1;
154:          maxx = x2;
155:        }
156:        else {
157:          minx = x2;
158:          maxx = x1;
159:        }
160:        if (y1 &lt; y2) {
161:          miny = y1;
162:          maxy = y2;
163:        }
164:        else {
165:          miny = y2;
166:          maxy = y1;
167:        }
168:      }
169:    
170:      /**
171:       *  Initialize an &lt;code&gt;Envelope&lt;/code&gt; to a region defined by two Coordinates.
172:       *
173:       *@param  p1  the first Coordinate
174:       *@param  p2  the second Coordinate
175:       */
176:      public void init(Coordinate p1, Coordinate p2)
177:      {
178:        init(p1.x, p2.x, p1.y, p2.y);
179:      }
180:    
181:      /**
182:       *  Initialize an &lt;code&gt;Envelope&lt;/code&gt; to a region defined by a single Coordinate.
183:       *
184:       *@param  p1  the first Coordinate
185:       *@param  p2  the second Coordinate
186:       */
187:      public void init(Coordinate p)
188:      {
189:        init(p.x, p.x, p.y, p.y);
190:      }
191:    
192:      /**
193:       *  Initialize an &lt;code&gt;Envelope&lt;/code&gt; from an existing Envelope.
194:       *
195:       *@param  env  the Envelope to initialize from
196:       */
197:      public void init(Envelope env)
198:      {
199:        init(env.minx, env.maxx, env.miny, env.maxy);
200:      }
201:    
202:    
203:      /**
204:       *  Makes this &lt;code&gt;Envelope&lt;/code&gt; a "null" envelope, that is, the envelope
205:       *  of the empty geometry.
206:       */
207:      public void setToNull() {
208:        minx = 0;
209:        maxx = -1;
210:        miny = 0;
211:        maxy = -1;
212:      }
213:    
214:      /**
215:       *  Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Envelope&lt;/code&gt; is a "null"
216:       *  envelope.
217:       *
218:       *@return    &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Envelope&lt;/code&gt; is uninitialized
219:       *      or is the envelope of the empty geometry.
220:       */
221:      public boolean isNull() {
222:        return maxx &lt; minx;
223:      }
224:    
225:      /**
226:       *  Returns the difference between the maximum and minimum x values.
227:       *
228:       *@return    max x - min x, or 0 if this is a null &lt;code&gt;Envelope&lt;/code&gt;
229:       */
230:      public double getWidth() {
231:        if (isNull()) {
232:          return 0;
233:        }
234:        return maxx - minx;
235:      }
236:    
237:      /**
238:       *  Returns the difference between the maximum and minimum y values.
239:       *
240:       *@return    max y - min y, or 0 if this is a null &lt;code&gt;Envelope&lt;/code&gt;
241:       */
242:      public double getHeight() {
243:        if (isNull()) {
244:          return 0;
245:        }
246:        return maxy - miny;
247:      }
248:    
249:      /**
250:       *  Returns the &lt;code&gt;Envelope&lt;/code&gt;s minimum x-value. min x &gt; max x
251:       *  indicates that this is a null &lt;code&gt;Envelope&lt;/code&gt;.
252:       *
253:       *@return    the minimum x-coordinate
254:       */
255:      public double getMinX() {
256:        return minx;
257:      }
258:    
259:      /**
260:       *  Returns the &lt;code&gt;Envelope&lt;/code&gt;s maximum x-value. min x &gt; max x
261:       *  indicates that this is a null &lt;code&gt;Envelope&lt;/code&gt;.
262:       *
263:       *@return    the maximum x-coordinate
264:       */
265:      public double getMaxX() {
266:        return maxx;
267:      }
268:    
269:      /**
270:       *  Returns the &lt;code&gt;Envelope&lt;/code&gt;s minimum y-value. min y &gt; max y
271:       *  indicates that this is a null &lt;code&gt;Envelope&lt;/code&gt;.
272:       *
273:       *@return    the minimum y-coordinate
274:       */
275:      public double getMinY() {
276:        return miny;
277:      }
278:    
279:      /**
280:       *  Returns the &lt;code&gt;Envelope&lt;/code&gt;s maximum y-value. min y &gt; max y
281:       *  indicates that this is a null &lt;code&gt;Envelope&lt;/code&gt;.
282:       *
283:       *@return    the maximum y-coordinate
284:       */
285:      public double getMaxY() {
286:        return maxy;
287:      }
288:    
289:      /**
290:       *  Enlarges the boundary of the &lt;code&gt;Envelope&lt;/code&gt; so that it contains
291:       *  (x,y). Does nothing if (x,y) is already on or within the boundaries.
292:       *
293:       *@param  x  the value to lower the minimum x to or to raise the maximum x to
294:       *@param  y  the value to lower the minimum y to or to raise the maximum y to
295:       */
296:      public void expandToInclude(Coordinate p)
297:      {
298:        expandToInclude(p.x, p.y);
299:      }
300:    
301:      //&lt;&lt;TODO:FEATURE&gt;&gt; #expandBy(double distance) [Jon Aquino]
302:    
303:      /**
304:       *  Enlarges the boundary of the &lt;code&gt;Envelope&lt;/code&gt; so that it contains
305:       *  (x,y). Does nothing if (x,y) is already on or within the boundaries.
306:       *
307:       *@param  x  the value to lower the minimum x to or to raise the maximum x to
308:       *@param  y  the value to lower the minimum y to or to raise the maximum y to
309:       */
310:      public void expandToInclude(double x, double y) {
311:        if (isNull()) {
312:          minx = x;
313:          maxx = x;
314:          miny = y;
315:          maxy = y;
316:        }
317:        else {
318:          if (x &lt; minx) {
319:            minx = x;
320:          }
321:          if (x &gt; maxx) {
322:            maxx = x;
323:          }
324:          if (y &lt; miny) {
325:            miny = y;
326:          }
327:          if (y &gt; maxy) {
328:            maxy = y;
329:          }
330:        }
331:      }
332:    
333:      /**
334:       *  Enlarges the boundary of the &lt;code&gt;Envelope&lt;/code&gt; so that it contains
335:       *  &lt;code&gt;other&lt;/code&gt;. Does nothing if &lt;code&gt;other&lt;/code&gt; is wholly on or
336:       *  within the boundaries.
337:       *
338:       *@param  other  the &lt;code&gt;Envelope&lt;/code&gt; to merge with
339:       */
340:      public void expandToInclude(Envelope other) {
341:        if (other.isNull()) {
342:          return;
343:        }
344:        if (isNull()) {
345:          minx = other.getMinX();
346:          maxx = other.getMaxX();
347:          miny = other.getMinY();
348:          maxy = other.getMaxY();
349:        }
350:        else {
351:          if (other.minx &lt; minx) {
352:            minx = other.minx;
353:          }
354:          if (other.maxx &gt; maxx) {
355:            maxx = other.maxx;
356:          }
357:          if (other.miny &lt; miny) {
358:            miny = other.miny;
359:          }
360:          if (other.maxy &gt; maxy) {
361:            maxy = other.maxy;
362:          }
363:        }
364:      }
365:    
366:      /**
367:       *  Returns &lt;code&gt;true&lt;/code&gt; if the given point lies in or on the envelope.
368:       *
369:       *@param  p  the point which this &lt;code&gt;Envelope&lt;/code&gt; is
370:       *      being checked for containing
371:       *@return    &lt;code&gt;true&lt;/code&gt; if the point lies in the interior or
372:       *      on the boundary of this &lt;code&gt;Envelope&lt;/code&gt;.
373:       */
374:      public boolean contains(Coordinate p) {
375:        return contains(p.x, p.y);
376:      }
377:    
378:      /**
379:       *  Returns &lt;code&gt;true&lt;/code&gt; if the given point lies in or on the envelope.
380:       *
381:       *@param  x  the x-coordinate of the point which this &lt;code&gt;Envelope&lt;/code&gt; is
382:       *      being checked for containing
383:       *@param  y  the y-coordinate of the point which this &lt;code&gt;Envelope&lt;/code&gt; is
384:       *      being checked for containing
385:       *@return    &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;(x, y)&lt;/code&gt; lies in the interior or
386:       *      on the boundary of this &lt;code&gt;Envelope&lt;/code&gt;.
387:       */
388:      public boolean contains(double x, double y) {
389:        return x &gt;= minx &amp;&amp;
390:            x &lt;= maxx &amp;&amp;
391:            y &gt;= miny &amp;&amp;
392:            y &lt;= maxy;
393:      }
394:    
395:      /**
396:       *  Check if the region defined by &lt;code&gt;other&lt;/code&gt;
397:       *  overlaps (intersects) the region of this &lt;code&gt;Envelope&lt;/code&gt;.
398:       *
399:       *@param  other  the &lt;code&gt;Envelope&lt;/code&gt; which this &lt;code&gt;Envelope&lt;/code&gt; is
400:       *          being checked for overlapping
401:       *@return        &lt;code&gt;true&lt;/code&gt; if the &lt;code&gt;Envelope&lt;/code&gt;s overlap
402:       */
403:      public boolean intersects(Envelope other) {
404:        return !(other.getMinX() &gt; maxx ||
405:            other.getMaxX() &lt; minx ||
406:            other.getMinY() &gt; maxy ||
407:            other.getMaxY() &lt; miny);
408:      }
409:      /**
410:       * @deprecated Use #intersects instead. In the future, #overlaps may be
411:       * changed to be a true overlap check; that is, whether the intersection is
412:       * two-dimensional.
413:       */
414:      public boolean overlaps(Envelope other) {
415:        return intersects(other);
416:      }
417:    
418:      /**
419:       *  Check if the point &lt;code&gt;p&lt;/code&gt;
420:       *  overlaps (lies inside) the region of this &lt;code&gt;Envelope&lt;/code&gt;.
421:       *
422:       *@param  other  the &lt;code&gt;Coordinate&lt;/code&gt; to be tested
423:       *@return        &lt;code&gt;true&lt;/code&gt; if the point overlaps this &lt;code&gt;Envelope&lt;/code&gt;
424:       */
425:      public boolean intersects(Coordinate p) {
426:        return intersects(p.x, p.y);
427:      }
428:      /**
429:       * @deprecated Use #intersects instead.
430:       */
431:      public boolean overlaps(Coordinate p) {
432:        return intersects(p);
433:      }
434:      /**
435:       *  Check if the point &lt;code&gt;(x, y)&lt;/code&gt;
436:       *  overlaps (lies inside) the region of this &lt;code&gt;Envelope&lt;/code&gt;.
437:       *
438:       *@param  x  the x-ordinate of the point
439:       *@param  y  the y-ordinate of the point
440:       *@return        &lt;code&gt;true&lt;/code&gt; if the point overlaps this &lt;code&gt;Envelope&lt;/code&gt;
441:       */
442:      public boolean intersects(double x, double y) {
443:        return ! (x &gt; maxx ||
444:            x &lt; minx ||
445:            y &gt; maxy ||
446:            y &lt; miny);
447:      }
448:      /**
449:       * @deprecated Use #intersects instead.
450:       */
451:      public boolean overlaps(double x, double y) {
452:        return intersects(x, y);
453:      }
454:    
455:      /**
456:       *  Returns &lt;code&gt;true&lt;/code&gt; if the &lt;code&gt;Envelope other&lt;/code&gt;
457:       *  lies wholely inside this &lt;code&gt;Envelope&lt;/code&gt; (inclusive of the boundary).
458:       *
459:       *@param  other  the &lt;code&gt;Envelope&lt;/code&gt; which this &lt;code&gt;Envelope&lt;/code&gt; is
460:       *        being checked for containing
461:       *@return        &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;other&lt;/code&gt;
462:       *              is contained in this &lt;code&gt;Envelope&lt;/code&gt;
463:       */
464:      public boolean contains(Envelope other) {
465:        return other.getMinX() &gt;= minx &amp;&amp;
466:            other.getMaxX() &lt;= maxx &amp;&amp;
467:            other.getMinY() &gt;= miny &amp;&amp;
468:            other.getMaxY() &lt;= maxy;
469:      }
470:    
471:      /**
472:       * Computes the distance between this and another
473:       * &lt;code&gt;Envelope&lt;/code&gt;.
474:       * The distance between overlapping Envelopes is 0.  Otherwise, the
475:       * distance is the Euclidean distance between the closest points.
476:       */
477:      public double distance(Envelope env)
478:      {
479:        if (intersects(env)) return 0;
<a name="diff" id="c6"><span class="HDDeleted">480:    </span></a><span class="HDDeleted">    if (maxx &lt; env.minx) {
</span><span class="HDDeleted">481:          // this is left of env
482:          if (maxy &lt; env.miny) {
483:            // this is below left of env
484:            return distance(maxx, maxy, env.minx, env.miny);
485:          }
486:          else if (miny &gt; env.maxy) {
487:            // this is above left of env
488:            return distance(maxx, miny, env.minx, env.maxy);
489:          }
490:          else {
491:            // this is directly left of env
492:            return env.minx - maxx;
493:          }
494:        }
495:        else {
496:          // this is right of env
497:          if (maxy &lt; env.miny) {
498:            // this is below right of env
499:            return distance(minx, maxy, env.maxx, env.miny);
500:          }
501:          else if (miny &gt; env.maxy) {
502:            // this is above right of env
503:            return distance(minx, miny, env.maxx, env.maxy);
504:          }
505:          else {
506:            // this is directly right of env
507:            return minx - env.maxx;
508:          }
509:        }
</span><span class="HDAdded">530:    </span><span class="HDAdded">    double dx = 0.0;
</span><span class="HDAdded">531:        if (maxx &lt; env.minx) dx = env.minx - maxx;
532:        if (minx &gt; env.maxx) dx = minx - env.maxx;
533:        double dy = 0.0;
534:        if (maxy &lt; env.miny) dy = env.miny - maxy;
535:        if (miny &gt; env.maxy) dy = miny - env.maxy;
536:    
537:        // if either is zero, the envelopes overlap either vertically or horizontally
538:        if (dx == 0.0) return dy;
539:        if (dy == 0.0) return dx;
540:        return Math.sqrt(dx * dx + dy * dy);
</span>510:      }
511:    
512:      public boolean equals(Object other) {
513:        if (!(other instanceof Envelope)) {
514:          return false;
515:        }
516:        Envelope otherEnvelope = (Envelope) other;
517:        if (isNull()) {
518:          return otherEnvelope.isNull();
519:        }
520:        return maxx == otherEnvelope.getMaxX() &amp;&amp;
521:            maxy == otherEnvelope.getMaxY() &amp;&amp;
522:            minx == otherEnvelope.getMinX() &amp;&amp;
523:            maxx == otherEnvelope.getMaxX();
524:      }
525:    
526:      public String toString()
527:      {
528:        return "Env[" + minx + " : " + maxx + ", " + miny + " : " + maxy + "]";
529:      }
530:    }
531:    
</pre>
</body>
<SCRIPT LANGUAGE="JavaScript" TYPE="text/javascript">
<!--
var newWind;
function putJumpCode(){
	var cnt = 7;
	newWind.document.write('<html>\n');
	newWind.document.write('<title>HtmlDiff Navigation</title>\n');
	newWind.document.write('<body>\n');
	newWind.document.write('<form name="jump">\n');
	newWind.document.write('<input type="button" value=" |&lt; " name="First" onclick=goto_first(this.form)>&nbsp;')
	newWind.document.write('<input type="button" value=" &lt; " name="Prev" onclick=goto_prev(this.form)>&nbsp;&nbsp;\n');
	newWind.document.write('<select name=url onchange=menu_goto(this.form)> \n');
	for (var i=0; i<cnt ;i++ ) {
		newWind.document.write('<option value="#C'+i+'">Change #'+(i+1)+ '</option> \n');
		}
	newWind.document.write('');
	newWind.document.write('</select>&nbsp;&nbsp;\n');
	newWind.document.write('<input type="button" value=" &gt; " name="Next"\n');
	newWind.document.write('onclick=goto_next(this.form)>\n');
	newWind.document.write('<input type="button" value=" &gt| " name="Last"\n');
	newWind.document.write('onclick=goto_last(this.form)>\n');
	newWind.document.write('</form>\n');
	newWind.document.write('');
	newWind.document.write('<form method="POST">\n');
	newWind.document.write('<p align="center"><i><font size="3">Generated\n');
	newWind.document.write('by <a href="http://www.ComponentSoftware.com/products/htmldiff" target="_blank">HtmlDiff</a> \n');
	newWind.document.write('</form>\n');
	newWind.document.write('</body>\n');
	newWind.document.write('</html>\n');
	newWind.document.write('<SCRIPT LANGUAGE="JavaScript" TYPE="text/javascript">\n');
	newWind.document.write('<!--\n');
	newWind.document.write('');
	newWind.document.write('var directCloseFlag=1;\n');
	newWind.document.write('');
	newWind.document.write('function menu_goto( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('  var baseurl = opener.location.href ;\n');
	newWind.document.write('  var idx = baseurl.indexOf("#");\n');
	newWind.document.write('  if (idx > -1) {\n');
	newWind.document.write('	baseurl = baseurl.slice(0, idx);\n');
	newWind.document.write('  }');
	newWind.document.write('  selecteditem = menuform.url.selectedIndex ;\n');
	newWind.document.write('  newurl = menuform.url.options[ selecteditem ].value ;\n');
	newWind.document.write('  if (newurl.length != 0) {\n');
	newWind.document.write('    	opener.top.location.href = baseurl + newurl ;\n');
	newWind.document.write('  }');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_prev( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	if(menuform.url.selectedIndex>0) menuform.url.selectedIndex--;\n');
	newWind.document.write('	menu_goto( menuform )\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_first( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	menuform.url.selectedIndex = 0;	\n');
	newWind.document.write('	menu_goto( menuform );\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_last( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	menuform.url.selectedIndex = menuform.url.options.length-1;	\n');
	newWind.document.write('	menu_goto( menuform );\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_next( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	if(menuform.url.options.length > (menuform.url.selectedIndex+1))\n');
	newWind.document.write('	menuform.url.selectedIndex++;\n');
	newWind.document.write('	menu_goto( menuform )\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function restore()\n');
	newWind.document.write('{\n');
	newWind.document.write('    	focus();\n');
	newWind.document.write('	menu_goto(jump);\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('goto_first(jump)\n');
	newWind.document.write('//-->\n');
	newWind.document.write('<');
	newWind.document.write('/SCRIPT>\n');
}
function pop_navigate(){
  if ((newWind==null)||(newWind.closed)) {
    newWind =  window.open("" ,"HtmlDiffJumpWindow","width=270,height=40")
    if (newWind.opener == null) { // for Nav 2.0x
      newWind.opener = self // this creates and sets a new prop
    }	putJumpCode();
  
} 
else 
{	newWind.execScript("restore()", "JavaScript");
  }
}
function exit(){
  if (newWind != null) {   
	newWind.close();
  }
}
//--></SCRIPT></html>
