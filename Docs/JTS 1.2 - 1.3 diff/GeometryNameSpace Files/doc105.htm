<body onunload=exit()><form method="POST">  <p align="center"><i><font size="3">Difference Analysis Generated by   <a href="http://www.ComponentSoftware.com/products/htmldiff" target="_blank">HtmlDiff</a> on  6/3/2003 11:47 AM</font></i>&nbsp;&nbsp;
  <input type="button" value="Navigate Changes" name="Navigate" onclick=pop_navigate()></p></form></body> <p align="left"><font size="4"><b>Base file: C:\Development\jts1.2\src\com\vividsolutions\jts\geom\GeometryFactory.java</b></font></p> <p align="left"><font size="4"><b>Modified file: C:\Development\jts1.3\src\com\vividsolutions\jts\geom\GeometryFactory.java</b></font></p><html>
<style type="text/css">
<!--
.HDNormal {  color: #000000;background:  #ffffff;text-decoration:none}
.HDDeleted {  color: #ff0000;background:  #ffffff;text-decoration:line-through}
.HDAdded {  color: #000000;background:  #ffff00;text-decoration:none}
-->
</style>
<body class="HDNormal">
<pre><a name="diff" id="c0"><span class="HDAdded">1:  
2:  
</span></a>1:  /*
2:   * <a name="diff" id="c1"><span class="HDDeleted"> </span></a>The <span class="HDDeleted">Java </span><span class="HDAdded">JTS </span>Topology Suite<span class="HDDeleted"> (JTS)</span> is a collection of Java classes that
3:   *  implement the fundamental operations required to validate a given
4:   *  geo-spatial data set to a known topological specification.
5:   *
6:   *  Copyright (C) 2001 Vivid Solutions
7:   *
8:   *  This library is free software; you can redistribute it and/or
9:   *  modify it under the terms of the GNU Lesser General Public
10:  *  License as published by the Free Software Foundation; either
11:  *  version 2.1 of the License, or (at your option) any later version.
12:  *
13:  *  This library is distributed in the hope that it will be useful,
14:  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
15:  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
16:  *  Lesser General Public License for more details.
17:  *
18:  *  You should have received a copy of the GNU Lesser General Public
19:  *  License along with this library; if not, write to the Free Software
20:  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
21:  *
22:  *  For more information, contact:
23:  *
24:  *  Vivid Solutions
25:  *  Suite #1A
26:  *  2328 Government Street
27:  *  Victoria BC  V8T 5G5
28:  *  Canada
29:  *
30:  *  (250)385-6040
31:  *  www.vividsolutions.com
32:  */
33: package com.vividsolutions.jts.geom;
34: 
<a name="diff" id="c2"><span class="HDAdded">37: import java.util.ArrayList;
38: import java.util.Iterator;
39: import java.util.List;
40: 
</span></a>35: import com.vividsolutions.jts.util.Assert;
<a name="diff" id="c3"><span class="HDDeleted">36: import java.util.*;
</span></a>37: 
38: /**
39:  *  Basic implementation of &lt;code&gt;GeometryFactory&lt;/code&gt;.
40:  *
41:  *@version 1.<a name="diff" id="c4"><span class="HDDeleted">2</span></a><span class="HDAdded">3</span>
42:  */
43: public class GeometryFactory<a name="diff" id="c5"><span class="HDDeleted"> {</span></a>
<span class="HDAdded">44: </span><span class="HDAdded">{
</span><span class="HDAdded">45: </span><span class="HDAdded">  public static Point createPointFromInternalCoord(Coordinate coord, Geometry exemplar)
</span><span class="HDAdded">46: </span><span class="HDAdded">  {
</span><span class="HDAdded">47: </span><span class="HDAdded">    exemplar.getPrecisionModel().makePrecise(coord);
</span><span class="HDAdded">48: </span><span class="HDAdded">    return new Point(coord, exemplar.getPrecisionModel(), exemplar.getSRID());
</span><span class="HDAdded">49: </span><span class="HDAdded">  }
</span>50:   /**
51:    *  The specification of the grid of allowable points for all &lt;code&gt;Geometry&lt;/code&gt;
52:    *  s created by this &lt;code&gt;GeometryFactory&lt;/code&gt;
53:    */
54:   private PrecisionModel precisionModel;
55:   /**
56:    *  The ID of the Spatial Reference System used by all &lt;code&gt;Geometry&lt;/code&gt;s.
57:    *  created by this &lt;code&gt;GeometryFactory&lt;/code&gt;
58:    */
59:   private int SRID;
60: 
61:   /**
62:    *  Creates a &lt;code&gt;GeometryFactory&lt;/code&gt; that creates &lt;code&gt;Geometry&lt;/code&gt;
63:    *  s using the given &lt;code&gt;precisionModel&lt;/code&gt; and &lt;code&gt;SRID&lt;/code&gt;.
64:    *
65:    *@param  precisionModel  the specification of the grid of allowable points
66:    *      for &lt;code&gt;Geometry&lt;/code&gt;s created by this &lt;code&gt;GeometryFactory&lt;/code&gt;
67:    *@param  SRID            the ID of the Spatial Reference System used by
68:    *      &lt;code&gt;Geometry&lt;/code&gt; created by this &lt;code&gt;GeometryFactory&lt;/code&gt;
69:    */
70:   public GeometryFactory(PrecisionModel precisionModel, int SRID) {
71:     this.precisionModel = precisionModel;
72:     this.SRID = SRID;
73:   }
74: 
75:   /**
76:    *  Creates a &lt;code&gt;GeometryFactoryImpl&lt;/code&gt; that creates &lt;code&gt;Geometry&lt;/code&gt;s
77:    *  using Floating &lt;code&gt;precisionModel&lt;/code&gt; and an &lt;code&gt;SRID&lt;/code&gt; of 0.
78:    */
79:   public GeometryFactory() {
80:     this(new PrecisionModel(), 0);
81:   }
82: 
83:   /**
84:    *  Converts the &lt;code&gt;List&lt;/code&gt; to an array.
85:    *
86:    *@param  points  the &lt;code&gt;List&lt;/code&gt; to convert
87:    *@return         the &lt;code&gt;List&lt;/code&gt; in array format
88:    */
89:   public static Point[] toPointArray(List points) {
90:     Point[] pointArray = new Point[points.size()];
91:     return (Point[]) points.toArray(pointArray);
92:   }
93: 
94:   /**
95:    *  Converts the &lt;code&gt;List&lt;/code&gt; to an array.
96:    *
97:    *@param  <a name="diff" id="c6"><span class="HDDeleted">geometrys  the list of &lt;code&gt;Geometrys</span></a><span class="HDAdded">geometries  the list of &lt;code&gt;Geometry's</span>&lt;/code&gt; to convert
98:    *@return            the &lt;code&gt;List&lt;/code&gt; in array format
99:    */
100:      public static Geometry[] toGeometryArray(List <a name="diff" id="c7"><span class="HDDeleted">geometrys</span></a><span class="HDAdded">geometries</span>) {
<span class="HDDeleted">101:    </span><span class="HDDeleted">    Geometry[] geometryArray = new Geometry[geometrys.size()];
</span><span class="HDDeleted">102:    </span><span class="HDDeleted">    return (Geometry[]) geometrys.toArray(geometryArray);
</span><span class="HDAdded">103:    </span><span class="HDAdded">    if (geometries == null) return null;
</span><span class="HDAdded">104:    </span><span class="HDAdded">    Geometry[] geometryArray = new Geometry[geometries.size()];
</span><span class="HDAdded">105:    </span><span class="HDAdded">    return (Geometry[]) geometries.toArray(geometryArray);
</span>106:      }
107:    
108:      /**
109:       *  Converts the &lt;code&gt;List&lt;/code&gt; to an array.
110:       *
111:       *@param  linearRings  the &lt;code&gt;List&lt;/code&gt; to convert
112:       *@return              the &lt;code&gt;List&lt;/code&gt; in array format
113:       */
114:      public static LinearRing[] toLinearRingArray(List linearRings) {
115:        LinearRing[] linearRingArray = new LinearRing[linearRings.size()];
116:        return (LinearRing[]) linearRings.toArray(linearRingArray);
117:      }
118:    
119:      /**
120:       *  Converts the &lt;code&gt;List&lt;/code&gt; to an array.
121:       *
122:       *@param  lineStrings  the &lt;code&gt;List&lt;/code&gt; to convert
123:       *@return              the &lt;code&gt;List&lt;/code&gt; in array format
124:       */
125:      public static LineString[] toLineStringArray(List lineStrings) {
126:        LineString[] lineStringArray = new LineString[lineStrings.size()];
127:        return (LineString[]) lineStrings.toArray(lineStringArray);
128:      }
129:    
130:      /**
131:       *  Converts the &lt;code&gt;List&lt;/code&gt; to an array.
132:       *
133:       *@param  polygons  the &lt;code&gt;List&lt;/code&gt; to convert
134:       *@return           the &lt;code&gt;List&lt;/code&gt; in array format
135:       */
136:      public static Polygon[] toPolygonArray(List polygons) {
137:        Polygon[] polygonArray = new Polygon[polygons.size()];
138:        return (Polygon[]) polygons.toArray(polygonArray);
139:      }
140:    
141:      /**
142:       *  Converts the &lt;code&gt;List&lt;/code&gt; to an array.
143:       *
144:       *@param  multiPolygons  the &lt;code&gt;List&lt;/code&gt; to convert
145:       *@return                the &lt;code&gt;List&lt;/code&gt; in array format
146:       */
147:      public static MultiPolygon[] toMultiPolygonArray(List multiPolygons) {
148:        MultiPolygon[] multiPolygonArray = new MultiPolygon[multiPolygons.size()];
149:        return (MultiPolygon[]) multiPolygons.toArray(multiPolygonArray);
150:      }
151:    
152:      /**
153:       *  Converts the &lt;code&gt;List&lt;/code&gt; to an array.
154:       *
155:       *@param  multiLineStrings  the &lt;code&gt;List&lt;/code&gt; to convert
156:       *@return                   the &lt;code&gt;List&lt;/code&gt; in array format
157:       */
158:      public static MultiLineString[] toMultiLineStringArray(List multiLineStrings) {
159:        MultiLineString[] multiLineStringArray = new MultiLineString[multiLineStrings.size()];
160:        return (MultiLineString[]) multiLineStrings.toArray(multiLineStringArray);
161:      }
162:    
163:      /**
164:       *  Converts the &lt;code&gt;List&lt;/code&gt; to an array.
165:       *
166:       *@param  multiPoints  the &lt;code&gt;List&lt;/code&gt; to convert
167:       *@return              the &lt;code&gt;List&lt;/code&gt; in array format
168:       */
169:      public static MultiPoint[] toMultiPointArray(List multiPoints) {
170:        MultiPoint[] multiPointArray = new MultiPoint[multiPoints.size()];
171:        return (MultiPoint[]) multiPoints.toArray(multiPointArray);
172:      }
173:    
174:      /**
175:       *  If the &lt;code&gt;Envelope&lt;/code&gt; is a null &lt;code&gt;Envelope&lt;/code&gt;, returns an
176:       *  empty &lt;code&gt;Point&lt;/code&gt;. If the &lt;code&gt;Envelope&lt;/code&gt; is a point, returns
177:       *  a non-empty &lt;code&gt;Point&lt;/code&gt;. If the &lt;code&gt;Envelope&lt;/code&gt; is a
178:       *  rectangle, returns a &lt;code&gt;Polygon&lt;/code&gt; whose points are (minx, miny),
179:       *  (maxx, miny), (maxx, maxy), (minx, maxy), (minx, miny).
180:       *
181:       *@param  envelope        the &lt;code&gt;Envelope&lt;/code&gt; to convert to a &lt;code&gt;Geometry&lt;/code&gt;
182:       *@param  precisionModel  the specification of the grid of allowable points
183:       *      for the new &lt;code&gt;Geometry&lt;/code&gt;
184:       *@param  SRID            the ID of the Spatial Reference System used by the
185:       *      &lt;code&gt;Envelope&lt;/code&gt;
186:       *@return                 an empty &lt;code&gt;Point&lt;/code&gt; (for null &lt;code&gt;Envelope&lt;/code&gt;
187:       *      s), a &lt;code&gt;Point&lt;/code&gt; (when min x = max x and min y = max y) or a
188:       *      &lt;code&gt;Polygon&lt;/code&gt; (in all other cases)
189:       *@throws  &lt;code&gt;         TopologyException&lt;/code&gt; if &lt;code&gt;coordinates&lt;/code&gt;
190:       *      is not a closed linestring, that is, if the first and last coordinates
191:       *      are not equal
192:       */
193:      public static Geometry toGeometry(Envelope envelope, PrecisionModel precisionModel,
194:          int SRID) {
195:        if (envelope.isNull()) {
196:          return new Point(null, precisionModel, SRID);
197:        }
198:        if (envelope.getMinX() == envelope.getMaxX() &amp;&amp; envelope.getMinY() == envelope.getMaxY()) {
199:          return new Point(new Coordinate(envelope.getMinX(), envelope.getMinY()), precisionModel, SRID);
200:        }
201:        return new Polygon(new LinearRing(new Coordinate[]{
202:            new Coordinate(envelope.getMinX(), envelope.getMinY()),
203:            new Coordinate(envelope.getMaxX(), envelope.getMinY()),
204:            new Coordinate(envelope.getMaxX(), envelope.getMaxY()),
205:            new Coordinate(envelope.getMinX(), envelope.getMaxY()),
206:            new Coordinate(envelope.getMinX(), envelope.getMinY())
207:            }, precisionModel, SRID), precisionModel, SRID);
208:      }
209:    
210:      public PrecisionModel getPrecisionModel() {
211:        return precisionModel;
212:      }
213:    
214:      public Point createPoint(Coordinate coordinate) {
215:        return new Point(coordinate, precisionModel, SRID);
216:      }
217:    
218:      public MultiLineString createMultiLineString(LineString[] lineStrings) {
219:        return new MultiLineString(lineStrings, precisionModel, SRID);
220:      }
221:    
222:      public GeometryCollection createGeometryCollection(Geometry[] geometries) {
223:        return new GeometryCollection(geometries, precisionModel, SRID);
224:      }
225:    
226:      public MultiPolygon createMultiPolygon(Polygon[] polygons) {
227:        return new MultiPolygon(polygons, precisionModel, SRID);
228:      }
229:    
230:      public LinearRing createLinearRing(Coordinate[] coordinates) {
231:        LinearRing linearRing = new LinearRing(coordinates, precisionModel, SRID);
232:        if (coordinates != null &amp;&amp; coordinates.length &gt; 0 &amp;&amp; !coordinates[0].equals2D(coordinates[
233:            coordinates.length - 1])) {
234:          throw new IllegalArgumentException("LinearRing not closed");
235:        }
236:        return linearRing;
237:      }
238:    
239:      public MultiPoint createMultiPoint(Point[] point) {
240:        return new MultiPoint(point, precisionModel, SRID);
241:      }
242:    
243:      public MultiPoint createMultiPoint(Coordinate[] coordinates) {
244:        if (coordinates == null) {
245:          coordinates = new Coordinate[]{};
246:        }
247:        ArrayList points = new ArrayList();
248:        for (int i = 0; i &lt; coordinates.length; i++) {
249:          points.add(createPoint(coordinates[i]));
250:        }
251:        return createMultiPoint((Point[]) points.toArray(new Point[]{}));
252:      }
253:    
254:      public Polygon createPolygon(LinearRing shell, LinearRing[] holes) {
255:        return new Polygon(shell, holes, precisionModel, SRID);
256:      }
257:    
258:      /**
259:       *  Build an appropriate &lt;code&gt;Geometry&lt;/code&gt;, &lt;code&gt;MultiGeometry&lt;/code&gt;, or
260:       *  &lt;code&gt;GeometryCollection&lt;/code&gt; to contain the &lt;code&gt;Geometry&lt;/code&gt;s in
261:       *  it; for example,&lt;br&gt;
262:       *
263:       *  &lt;ul&gt;
264:       *    &lt;li&gt; If &lt;code&gt;geomList&lt;/code&gt; contains a single &lt;code&gt;Polygon&lt;/code&gt;,
265:       *    the &lt;code&gt;Polygon&lt;/code&gt; is returned.
266:       *    &lt;li&gt; If &lt;code&gt;geomList&lt;/code&gt; contains several &lt;code&gt;Polygon&lt;/code&gt;s, a
267:       *    &lt;code&gt;MultiPolygon&lt;/code&gt; is returned.
268:       *    &lt;li&gt; If &lt;code&gt;geomList&lt;/code&gt; contains some &lt;code&gt;Polygon&lt;/code&gt;s and
269:       *    some &lt;code&gt;LineString&lt;/code&gt;s, a &lt;code&gt;GeometryCollection&lt;/code&gt; is
270:       *    returned.
271:       *    &lt;li&gt; If &lt;code&gt;geomList&lt;/code&gt; is empty, an empty &lt;code&gt;GeometryCollection&lt;/code&gt;
272:       *    is returned
273:       *  &lt;/ul&gt;
274:       *
275:       *
276:       *@param  geomList  the &lt;code&gt;Geometry&lt;/code&gt;s to combine
277:       *@return           a &lt;code&gt;Geometry&lt;/code&gt; of the "smallest", "most
278:       *      type-specific" class that can contain the elements of &lt;code&gt;geomList&lt;/code&gt;
279:       *      .
280:       */
281:      public Geometry buildGeometry(List geomList) {
282:        Class geomClass = null;
283:        boolean isHeterogeneous = false;
284:        boolean isCollection = geomList.size() &gt; 1;
285:        for (Iterator i = geomList.iterator(); i.hasNext(); ) {
286:          Geometry geom = (Geometry) i.next();
287:          Class partClass = geom.getClass();
288:          if (geomClass == null) {
289:            geomClass = partClass;
290:          }
291:          if (partClass != geomClass) {
292:            isHeterogeneous = true;
293:          }
294:        }
295:        // for the empty geometry, return an empty GeometryCollection
296:        if (geomClass == null) {
297:          return createGeometryCollection(null);
298:        }
299:        if (isHeterogeneous) {
300:          return createGeometryCollection(toGeometryArray(geomList));
301:        }
302:        Geometry geom0 = (Geometry) geomList.get(0);
303:        if (isCollection) {
304:          if (geom0 instanceof Polygon) {
305:            return createMultiPolygon(toPolygonArray(geomList));
306:          }
307:          else if (geom0 instanceof LineString) {
308:            return createMultiLineString(toLineStringArray(geomList));
309:          }
310:          else if (geom0 instanceof Point) {
311:            return createMultiPoint(toPointArray(geomList));
312:          }
313:          Assert.shouldNeverReachHere();
314:        }
315:        return geom0;
316:      }
317:    
318:      public LineString createLineString(Coordinate[] coordinates) {
319:        return new LineString(coordinates, precisionModel, SRID);
320:      }
321:    }
322:    
</pre>
</body>
<SCRIPT LANGUAGE="JavaScript" TYPE="text/javascript">
<!--
var newWind;
function putJumpCode(){
	var cnt = 8;
	newWind.document.write('<html>\n');
	newWind.document.write('<title>HtmlDiff Navigation</title>\n');
	newWind.document.write('<body>\n');
	newWind.document.write('<form name="jump">\n');
	newWind.document.write('<input type="button" value=" |&lt; " name="First" onclick=goto_first(this.form)>&nbsp;')
	newWind.document.write('<input type="button" value=" &lt; " name="Prev" onclick=goto_prev(this.form)>&nbsp;&nbsp;\n');
	newWind.document.write('<select name=url onchange=menu_goto(this.form)> \n');
	for (var i=0; i<cnt ;i++ ) {
		newWind.document.write('<option value="#C'+i+'">Change #'+(i+1)+ '</option> \n');
		}
	newWind.document.write('');
	newWind.document.write('</select>&nbsp;&nbsp;\n');
	newWind.document.write('<input type="button" value=" &gt; " name="Next"\n');
	newWind.document.write('onclick=goto_next(this.form)>\n');
	newWind.document.write('<input type="button" value=" &gt| " name="Last"\n');
	newWind.document.write('onclick=goto_last(this.form)>\n');
	newWind.document.write('</form>\n');
	newWind.document.write('');
	newWind.document.write('<form method="POST">\n');
	newWind.document.write('<p align="center"><i><font size="3">Generated\n');
	newWind.document.write('by <a href="http://www.ComponentSoftware.com/products/htmldiff" target="_blank">HtmlDiff</a> \n');
	newWind.document.write('</form>\n');
	newWind.document.write('</body>\n');
	newWind.document.write('</html>\n');
	newWind.document.write('<SCRIPT LANGUAGE="JavaScript" TYPE="text/javascript">\n');
	newWind.document.write('<!--\n');
	newWind.document.write('');
	newWind.document.write('var directCloseFlag=1;\n');
	newWind.document.write('');
	newWind.document.write('function menu_goto( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('  var baseurl = opener.location.href ;\n');
	newWind.document.write('  var idx = baseurl.indexOf("#");\n');
	newWind.document.write('  if (idx > -1) {\n');
	newWind.document.write('	baseurl = baseurl.slice(0, idx);\n');
	newWind.document.write('  }');
	newWind.document.write('  selecteditem = menuform.url.selectedIndex ;\n');
	newWind.document.write('  newurl = menuform.url.options[ selecteditem ].value ;\n');
	newWind.document.write('  if (newurl.length != 0) {\n');
	newWind.document.write('    	opener.top.location.href = baseurl + newurl ;\n');
	newWind.document.write('  }');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_prev( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	if(menuform.url.selectedIndex>0) menuform.url.selectedIndex--;\n');
	newWind.document.write('	menu_goto( menuform )\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_first( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	menuform.url.selectedIndex = 0;	\n');
	newWind.document.write('	menu_goto( menuform );\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_last( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	menuform.url.selectedIndex = menuform.url.options.length-1;	\n');
	newWind.document.write('	menu_goto( menuform );\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_next( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	if(menuform.url.options.length > (menuform.url.selectedIndex+1))\n');
	newWind.document.write('	menuform.url.selectedIndex++;\n');
	newWind.document.write('	menu_goto( menuform )\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function restore()\n');
	newWind.document.write('{\n');
	newWind.document.write('    	focus();\n');
	newWind.document.write('	menu_goto(jump);\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('goto_first(jump)\n');
	newWind.document.write('//-->\n');
	newWind.document.write('<');
	newWind.document.write('/SCRIPT>\n');
}
function pop_navigate(){
  if ((newWind==null)||(newWind.closed)) {
    newWind =  window.open("" ,"HtmlDiffJumpWindow","width=270,height=40")
    if (newWind.opener == null) { // for Nav 2.0x
      newWind.opener = self // this creates and sets a new prop
    }	putJumpCode();
  
} 
else 
{	newWind.execScript("restore()", "JavaScript");
  }
}
function exit(){
  if (newWind != null) {   
	newWind.close();
  }
}
//--></SCRIPT></html>
