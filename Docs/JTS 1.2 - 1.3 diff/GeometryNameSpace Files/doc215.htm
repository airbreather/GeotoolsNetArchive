<body onunload=exit()><form method="POST">  <p align="center"><i><font size="3">Difference Analysis Generated by   <a href="http://www.ComponentSoftware.com/products/htmldiff" target="_blank">HtmlDiff</a> on  6/3/2003 11:47 AM</font></i>&nbsp;&nbsp;
  <input type="button" value="Navigate Changes" name="Navigate" onclick=pop_navigate()></p></form></body> <p align="left"><font size="4"><b>Base file: C:\Development\jts1.2\src\com\vividsolutions\jts\geom\Polygon.java</b></font></p> <p align="left"><font size="4"><b>Modified file: C:\Development\jts1.3\src\com\vividsolutions\jts\geom\Polygon.java</b></font></p><html>
<style type="text/css">
<!--
.HDNormal {  color: #000000;background:  #ffffff;text-decoration:none}
.HDDeleted {  color: #ff0000;background:  #ffffff;text-decoration:line-through}
.HDAdded {  color: #000000;background:  #ffff00;text-decoration:none}
-->
</style>
<body class="HDNormal">
<pre><a name="diff" id="c0"><span class="HDAdded">1:  
2:  
</span></a>1:  /*
2:   * <a name="diff" id="c1"><span class="HDDeleted"> </span></a>The <span class="HDDeleted">Java </span><span class="HDAdded">JTS </span>Topology Suite<span class="HDDeleted"> (JTS)</span> is a collection of Java classes that
3:   *  implement the fundamental operations required to validate a given
4:   *  geo-spatial data set to a known topological specification.
5:   *
6:   *  Copyright (C) 2001 Vivid Solutions
7:   *
8:   *  This library is free software; you can redistribute it and/or
9:   *  modify it under the terms of the GNU Lesser General Public
10:  *  License as published by the Free Software Foundation; either
11:  *  version 2.1 of the License, or (at your option) any later version.
12:  *
13:  *  This library is distributed in the hope that it will be useful,
14:  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
15:  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
16:  *  Lesser General Public License for more details.
17:  *
18:  *  You should have received a copy of the GNU Lesser General Public
19:  *  License along with this library; if not, write to the Free Software
20:  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
21:  *
22:  *  For more information, contact:
23:  *
24:  *  Vivid Solutions
25:  *  Suite #1A
26:  *  2328 Government Street
27:  *  Victoria BC  V8T 5G5
28:  *  Canada
29:  *
30:  *  (250)385-6040
31:  *  www.vividsolutions.com
32:  */
33: package com.vividsolutions.jts.geom;
34: 
<a name="diff" id="c2"><span class="HDDeleted">35: import com.vividsolutions.jts.geom.sfs.SFSPolygon;
36: import com.vividsolutions.jts.algorithm.ConvexHull;
37: import com.vividsolutions.jts.algorithm.CGAlgorithms;
38: 
39: import java.util.ArrayList;
</span></a>40: import java.util.Arrays;
<a name="diff" id="c3"><span class="HDDeleted">41: </span></a><span class="HDDeleted">import java.util.Collections;
</span><span class="HDAdded">42: </span><span class="HDAdded">
</span><span class="HDAdded">43: </span><span class="HDAdded">import com.vividsolutions.jts.algorithm.CGAlgorithms;
</span><span class="HDAdded">44: </span><span class="HDAdded">import com.vividsolutions.jts.geom.sfs.SFSPolygon;
</span>45: 
46: /**
47:  *  Basic implementation of &lt;code&gt;Polygon&lt;/code&gt;.
48:  *
49:  *@version 1.<a name="diff" id="c4"><span class="HDDeleted">2</span></a><span class="HDAdded">3</span>
50:  */
51: public class Polygon extends Geometry implements SFSPolygon {
52:   /**
53:    *  The exterior boundary, or &lt;code&gt;null&lt;/code&gt; if this &lt;code&gt;Polygon&lt;/code&gt;
54:    *  is the empty geometry.
55:    */
56:   protected LinearRing shell = null;
57: 
58:   /**
59:    *  The interior boundaries, if any.
60:    */
61:   protected LinearRing[] holes;
62: 
63:   /**
64:    *  Constructs a &lt;code&gt;Polygon&lt;/code&gt; with the given exterior boundary.
65:    *  The shell and holes must conform to the assertions specified in the &lt;A
66:    *  HREF="http://www.opengis.org/techno/specs.htm"&gt;OpenGIS Simple Features
67:    *  Specification for SQL&lt;/A&gt; .
68:    *
69:    *@param  shell           the outer boundary of the new &lt;code&gt;Polygon&lt;/code&gt;,
70:    *      or &lt;code&gt;null&lt;/code&gt; or an empty &lt;code&gt;LinearRing&lt;/code&gt; if the empty
71:    *      geometry is to be created. Must be oriented clockwise.
72:    *@param  precisionModel  the specification of the grid of allowable points
73:    *      for this &lt;code&gt;Polygon&lt;/code&gt;
74:    *@param  SRID            the ID of the Spatial Reference System used by this
75:    *      &lt;code&gt;Polygon&lt;/code&gt;
76:    */
77:   public Polygon(LinearRing shell, PrecisionModel precisionModel, int SRID) {
78:     this(shell, new LinearRing[]{}, precisionModel, SRID);
79:   }
80: 
81:   /**
82:    *  Constructs a &lt;code&gt;Polygon&lt;/code&gt; with the given exterior boundary and
83:    *  interior boundaries.
84:    *
85:    *@param  shell           the outer boundary of the new &lt;code&gt;Polygon&lt;/code&gt;,
86:    *      or &lt;code&gt;null&lt;/code&gt; or an empty &lt;code&gt;LinearRing&lt;/code&gt; if the empty
87:    *      geometry is to be created. Must be oriented clockwise.
88:    *@param  holes           the inner boundaries of the new &lt;code&gt;Polygon&lt;/code&gt;
89:    *      , or &lt;code&gt;null&lt;/code&gt; or empty &lt;code&gt;LinearRing&lt;/code&gt;s if the empty
90:    *      geometry is to be created. Each must be oriented counterclockwise.
91:    *@param  precisionModel  the specification of the grid of allowable points
92:    *      for this &lt;code&gt;Polygon&lt;/code&gt;
93:    *@param  SRID            the ID of the Spatial Reference System used by this
94:    *      &lt;code&gt;Polygon&lt;/code&gt;
95:    */
96:   public Polygon(LinearRing shell, LinearRing[] holes, PrecisionModel precisionModel, int SRID) {
97:     super(precisionModel, SRID);
98:     if (shell == null) {
99:       shell = new LinearRing(null, precisionModel, SRID);
100:        }
101:        if (holes == null) {
102:          holes = new LinearRing[]{};
103:        }
104:        if (hasNullElements(holes)) {
105:          throw new IllegalArgumentException("holes must not contain null elements");
106:        }
107:        if (shell.isEmpty() &amp;&amp; hasNonEmptyElements(holes)) {
108:          throw new IllegalArgumentException("shell is empty but holes are not");
109:        }
110:        this.shell = shell;
111:        this.holes = holes;
112:      }
113:    
114:      public Coordinate getCoordinate() {
115:        return shell.getCoordinate();
116:      }
117:    
118:      public Coordinate[] getCoordinates() {
119:        if (isEmpty()) {
120:          return new Coordinate[]{};
121:        }
122:        Coordinate[] coordinates = new Coordinate[getNumPoints()];
123:        int k = -1;
124:        Coordinate[] shellCoordinates = shell.getCoordinates();
125:        for (int x = 0; x &lt; shellCoordinates.length; x++) {
126:          k++;
127:          coordinates[k] = shellCoordinates[x];
128:        }
129:        for (int i = 0; i &lt; holes.length; i++) {
130:          Coordinate[] childCoordinates = holes[i].getCoordinates();
131:          for (int j = 0; j &lt; childCoordinates.length; j++) {
132:            k++;
133:            coordinates[k] = childCoordinates[j];
134:          }
135:        }
136:        return coordinates;
137:      }
138:    
139:      public int getNumPoints() {
140:        int numPoints = shell.getNumPoints();
141:        for (int i = 0; i &lt; holes.length; i++) {
142:          numPoints += holes[i].getNumPoints();
143:        }
144:        return numPoints;
145:      }
146:    
147:      public int getDimension() {
148:        return 2;
149:      }
150:    
151:      public int getBoundaryDimension() {
152:        return 1;
153:      }
154:    
155:      public boolean isEmpty() {
156:        return shell.isEmpty();
157:      }
158:    
159:      public boolean isSimple() {
160:        return true;
161:      }
162:    
163:      public LineString getExteriorRing() {
164:        return shell;
165:      }
166:    
167:      public int getNumInteriorRing() {
168:        return holes.length;
169:      }
170:    
171:      public LineString getInteriorRingN(int n) {
172:        return holes[n];
173:      }
174:    
175:      public String getGeometryType() {
176:        return "Polygon";
177:      }
178:    
179:      /**
180:       *  Returns the area of this &lt;code&gt;Polygon&lt;/code&gt;
181:       *
182:       *@return the area of the polygon
183:       */
184:      public double getArea()
185:      {
186:        double area = 0.0;
187:        area += Math.abs(CGAlgorithms.signedArea(shell.getCoordinates()));
188:        for (int i = 0; i &lt; holes.length; i++) {
189:          area -= Math.abs(CGAlgorithms.signedArea(holes[i].getCoordinates()));
190:        }
191:        return area;
192:      }
193:    
194:      /**
195:       *  Returns the perimeter of this &lt;code&gt;Polygon&lt;/code&gt;
196:       *
197:       *@return the perimeter of the polygon
198:       */
199:      public double getLength()
200:      {
201:        double len = 0.0;
202:        len += shell.getLength();
203:        for (int i = 0; i &lt; holes.length; i++) {
204:          len += holes[i].getLength();
205:        }
206:        return len;
207:      }
208:    
209:      public Geometry getBoundary() {
210:        if (isEmpty()) {
211:          return new GeometryCollection(null, precisionModel, SRID);
212:        }
213:        LinearRing[] rings = new LinearRing[holes.length + 1];
214:        rings[0] = shell;
215:        for (int i = 0; i &lt; holes.length; i++) {
216:          rings[i + 1] = holes[i];
217:        }
218:        return new MultiLineString(rings, precisionModel, SRID);
219:      }
220:    
221:      protected Envelope computeEnvelopeInternal() {
222:        return shell.getEnvelopeInternal();
223:      }
224:    
225:      public boolean equalsExact(Geometry other<a name="diff" id="c5"><span class="HDAdded">, double tolerance</span></a>) {
226:        if (!isEquivalentClass(other)) {
227:          return false;
228:        }
229:        Polygon otherPolygon = (Polygon) other;
230:        if (!(shell instanceof Geometry)) {
231:          return false;
232:        }
233:        Geometry thisShell = shell;
234:        if (!(otherPolygon.shell instanceof Geometry)) {
235:          return false;
236:        }
237:        Geometry otherPolygonShell = otherPolygon.shell;
238:        if (!thisShell.equalsExact(otherPolygonShell<a name="diff" id="c6"><span class="HDAdded">, tolerance</span></a>)) {
239:          return false;
240:        }
241:        if (holes.length != otherPolygon.holes.length) {
242:          return false;
243:        }
244:        if (holes.length != otherPolygon.holes.length) {
245:          return false;
246:        }
247:        for (int i = 0; i &lt; holes.length; i++) {
248:          if (!(holes[i] instanceof Geometry)) {
249:            return false;
250:          }
251:          if (!(otherPolygon.holes[i] instanceof Geometry)) {
252:            return false;
253:          }
254:          if (!((Geometry) holes[i]).equalsExact((Geometry) otherPolygon.holes[i]<a name="diff" id="c7"><span class="HDAdded">, tolerance</span></a>)) {
255:            return false;
256:          }
257:        }
258:        return true;
259:      }
260:    
261:      public void apply(CoordinateFilter filter) {
262:        shell.apply(filter);
263:        for (int i = 0; i &lt; holes.length; i++) {
264:          holes[i].apply(filter);
265:        }
266:      }
267:    
268:      public void apply(GeometryFilter filter) {
269:        filter.filter(this);
270:      }
271:    
272:      public void apply(GeometryComponentFilter filter) {
273:        filter.filter(this);
274:        shell.apply(filter);
275:        for (int i = 0; i &lt; holes.length; i++) {
276:          holes[i].apply(filter);
277:        }
278:      }
279:    
280:      public Object clone() {
281:        Polygon poly = (Polygon) super.clone();
282:        poly.shell = (LinearRing) shell.clone();
283:        poly.holes = new LinearRing[holes.length];
284:        for (int i = 0; i &lt; holes.length; i++) {
285:          poly.holes[i] = (LinearRing) holes[i].clone();
286:        }
287:        return poly;// return the clone
288:      }
289:    
290:      public Geometry convexHull() {
291:        return getExteriorRing().convexHull();
292:      }
293:    
294:      public void normalize() {
295:        normalize(shell, true);
296:        for (int i = 0; i &lt; holes.length; i++) {
297:          normalize(holes[i], false);
298:        }
299:        Arrays.sort(holes);
300:      }
301:    
302:      protected int compareToSameClass(Object o) {
303:        LinearRing thisShell = shell;
304:        LinearRing otherShell = ((Polygon) o).shell;
305:        return thisShell.compareToSameClass(otherShell);
306:      }
307:    
308:      private void normalize(LinearRing ring, boolean clockwise) {
309:        if (ring.isEmpty()) {
310:          return;
311:        }
312:        Coordinate[] uniqueCoordinates = new Coordinate[ring.getCoordinates().length - 1];
313:        System.arraycopy(ring.getCoordinates(), 0, uniqueCoordinates, 0, uniqueCoordinates.length);
314:        Coordinate minCoordinate = <a name="diff" id="c8"><span class="HDAdded">CoordinateArrays.</span></a>minCoordinate(ring.getCoordinates());
315:        <span class="HDAdded">CoordinateArrays.</span>scroll(uniqueCoordinates, minCoordinate);
316:        System.arraycopy(uniqueCoordinates, 0, ring.getCoordinates(), 0, uniqueCoordinates.length);
317:        ring.getCoordinates()[uniqueCoordinates.length] = uniqueCoordinates[0];
318:        if (cgAlgorithms.isCCW(ring.getCoordinates()) == clockwise) {
319:          <a name="diff" id="c9"><span class="HDAdded">CoordinateArrays.</span></a>reverse<span class="HDDeleted">PointOrder</span>(ring.getCoordinates());
320:        }
321:      }
322:    
323:    }
324:    
</pre>
</body>
<SCRIPT LANGUAGE="JavaScript" TYPE="text/javascript">
<!--
var newWind;
function putJumpCode(){
	var cnt = 10;
	newWind.document.write('<html>\n');
	newWind.document.write('<title>HtmlDiff Navigation</title>\n');
	newWind.document.write('<body>\n');
	newWind.document.write('<form name="jump">\n');
	newWind.document.write('<input type="button" value=" |&lt; " name="First" onclick=goto_first(this.form)>&nbsp;')
	newWind.document.write('<input type="button" value=" &lt; " name="Prev" onclick=goto_prev(this.form)>&nbsp;&nbsp;\n');
	newWind.document.write('<select name=url onchange=menu_goto(this.form)> \n');
	for (var i=0; i<cnt ;i++ ) {
		newWind.document.write('<option value="#C'+i+'">Change #'+(i+1)+ '</option> \n');
		}
	newWind.document.write('');
	newWind.document.write('</select>&nbsp;&nbsp;\n');
	newWind.document.write('<input type="button" value=" &gt; " name="Next"\n');
	newWind.document.write('onclick=goto_next(this.form)>\n');
	newWind.document.write('<input type="button" value=" &gt| " name="Last"\n');
	newWind.document.write('onclick=goto_last(this.form)>\n');
	newWind.document.write('</form>\n');
	newWind.document.write('');
	newWind.document.write('<form method="POST">\n');
	newWind.document.write('<p align="center"><i><font size="3">Generated\n');
	newWind.document.write('by <a href="http://www.ComponentSoftware.com/products/htmldiff" target="_blank">HtmlDiff</a> \n');
	newWind.document.write('</form>\n');
	newWind.document.write('</body>\n');
	newWind.document.write('</html>\n');
	newWind.document.write('<SCRIPT LANGUAGE="JavaScript" TYPE="text/javascript">\n');
	newWind.document.write('<!--\n');
	newWind.document.write('');
	newWind.document.write('var directCloseFlag=1;\n');
	newWind.document.write('');
	newWind.document.write('function menu_goto( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('  var baseurl = opener.location.href ;\n');
	newWind.document.write('  var idx = baseurl.indexOf("#");\n');
	newWind.document.write('  if (idx > -1) {\n');
	newWind.document.write('	baseurl = baseurl.slice(0, idx);\n');
	newWind.document.write('  }');
	newWind.document.write('  selecteditem = menuform.url.selectedIndex ;\n');
	newWind.document.write('  newurl = menuform.url.options[ selecteditem ].value ;\n');
	newWind.document.write('  if (newurl.length != 0) {\n');
	newWind.document.write('    	opener.top.location.href = baseurl + newurl ;\n');
	newWind.document.write('  }');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_prev( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	if(menuform.url.selectedIndex>0) menuform.url.selectedIndex--;\n');
	newWind.document.write('	menu_goto( menuform )\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_first( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	menuform.url.selectedIndex = 0;	\n');
	newWind.document.write('	menu_goto( menuform );\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_last( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	menuform.url.selectedIndex = menuform.url.options.length-1;	\n');
	newWind.document.write('	menu_goto( menuform );\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_next( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	if(menuform.url.options.length > (menuform.url.selectedIndex+1))\n');
	newWind.document.write('	menuform.url.selectedIndex++;\n');
	newWind.document.write('	menu_goto( menuform )\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function restore()\n');
	newWind.document.write('{\n');
	newWind.document.write('    	focus();\n');
	newWind.document.write('	menu_goto(jump);\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('goto_first(jump)\n');
	newWind.document.write('//-->\n');
	newWind.document.write('<');
	newWind.document.write('/SCRIPT>\n');
}
function pop_navigate(){
  if ((newWind==null)||(newWind.closed)) {
    newWind =  window.open("" ,"HtmlDiffJumpWindow","width=270,height=40")
    if (newWind.opener == null) { // for Nav 2.0x
      newWind.opener = self // this creates and sets a new prop
    }	putJumpCode();
  
} 
else 
{	newWind.execScript("restore()", "JavaScript");
  }
}
function exit(){
  if (newWind != null) {   
	newWind.close();
  }
}
//--></SCRIPT></html>
