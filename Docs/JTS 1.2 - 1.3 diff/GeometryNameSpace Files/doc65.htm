<body onunload=exit()><form method="POST">  <p align="center"><i><font size="3">Difference Analysis Generated by   <a href="http://www.ComponentSoftware.com/products/htmldiff" target="_blank">HtmlDiff</a> on  6/3/2003 11:47 AM</font></i>&nbsp;&nbsp;
  <input type="button" value="Navigate Changes" name="Navigate" onclick=pop_navigate()></p></form></body> <p align="left"><font size="4"><b>Base file: C:\Development\jts1.2\src\com\vividsolutions\jts\geom\Geometry.java</b></font></p> <p align="left"><font size="4"><b>Modified file: C:\Development\jts1.3\src\com\vividsolutions\jts\geom\Geometry.java</b></font></p><html>
<style type="text/css">
<!--
.HDNormal {  color: #000000;background:  #ffffff;text-decoration:none}
.HDDeleted {  color: #ff0000;background:  #ffffff;text-decoration:line-through}
.HDAdded {  color: #000000;background:  #ffff00;text-decoration:none}
-->
</style>
<body class="HDNormal">
<pre><a name="diff" id="c0"><span class="HDAdded">1:  
2:  
</span></a>1:  /*
2:   * <a name="diff" id="c1"><span class="HDDeleted"> </span></a>The <span class="HDDeleted">Java </span><span class="HDAdded">JTS </span>Topology Suite<span class="HDDeleted"> (JTS)</span> is a collection of Java classes that
3:   *  implement the fundamental operations required to validate a given
4:   *  geo-spatial data set to a known topological specification.
5:   *
6:   *  Copyright (C) 2001 Vivid Solutions
7:   *
8:   *  This library is free software; you can redistribute it and/or
9:   *  modify it under the terms of the GNU Lesser General Public
10:  *  License as published by the Free Software Foundation; either
11:  *  version 2.1 of the License, or (at your option) any later version.
12:  *
13:  *  This library is distributed in the hope that it will be useful,
14:  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
15:  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
16:  *  Lesser General Public License for more details.
17:  *
18:  *  You should have received a copy of the GNU Lesser General Public
19:  *  License along with this library; if not, write to the Free Software
20:  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
21:  *
22:  *  For more information, contact:
23:  *
24:  *  Vivid Solutions
25:  *  Suite #1A
26:  *  2328 Government Street
27:  *  Victoria BC  V8T 5G5
28:  *  Canada
29:  *
30:  *  (250)385-6040
31:  *  www.vividsolutions.com
32:  */
33: package com.vividsolutions.jts.geom;
34: 
<a name="diff" id="c2"><span class="HDDeleted">35: </span></a><span class="HDDeleted">import com.vividsolutions.jts.geom.sfs.SFSGeometry;
</span><span class="HDAdded">36: </span><span class="HDAdded">import java.io.Serializable;
</span><span class="HDAdded">37: </span><span class="HDAdded">import java.util.Collection;
</span><span class="HDAdded">38: </span><span class="HDAdded">import java.util.Iterator;
</span>39: 
40: import com.vividsolutions.jts.algorithm.<a name="diff" id="c3"><span class="HDDeleted">*</span></a><span class="HDAdded">CGAlgorithms</span>;
<span class="HDAdded">41: </span><span class="HDAdded">import com.vividsolutions.jts.algorithm.CentroidArea;
</span><span class="HDAdded">42: </span><span class="HDAdded">import com.vividsolutions.jts.algorithm.CentroidLine;
</span><span class="HDAdded">43: </span><span class="HDAdded">import com.vividsolutions.jts.algorithm.CentroidPoint;
</span><span class="HDAdded">44: </span><span class="HDAdded">import com.vividsolutions.jts.algorithm.ConvexHull;
</span><span class="HDAdded">45: </span><span class="HDAdded">import com.vividsolutions.jts.algorithm.InteriorPointArea;
</span><span class="HDAdded">46: </span><span class="HDAdded">import com.vividsolutions.jts.algorithm.InteriorPointLine;
</span><span class="HDAdded">47: </span><span class="HDAdded">import com.vividsolutions.jts.algorithm.InteriorPointPoint;
</span><span class="HDAdded">48: </span><span class="HDAdded">import com.vividsolutions.jts.algorithm.RobustCGAlgorithms;
</span><span class="HDAdded">49: </span><span class="HDAdded">import com.vividsolutions.jts.geom.sfs.SFSGeometry;
</span><span class="HDAdded">50: </span><span class="HDAdded">import com.vividsolutions.jts.io.WKTWriter;
</span>51: import com.vividsolutions.jts.operation.buffer.BufferOp;
<a name="diff" id="c4"><span class="HDAdded">53: import com.vividsolutions.jts.operation.distance.DistanceOp;
</span></a>52: import com.vividsolutions.jts.operation.overlay.OverlayOp;
53: import com.vividsolutions.jts.operation.relate.RelateOp;
54: import com.vividsolutions.jts.operation.valid.IsValidOp;
55: import com.vividsolutions.jts.<a name="diff" id="c5"><span class="HDDeleted">operation.distance.DistanceOp</span></a><span class="HDAdded">util.Assert</span>;
<span class="HDDeleted">56: </span><span class="HDDeleted">import com.vividsolutions.jts.io.WKTWriter;
</span><span class="HDDeleted">57: </span><span class="HDDeleted">import com.vividsolutions.jts.util.*;
</span><span class="HDDeleted">58: </span><span class="HDDeleted">
</span><span class="HDDeleted">59: </span><span class="HDDeleted">import java.util.Arrays;
</span><span class="HDDeleted">60: </span><span class="HDDeleted">import java.util.Collection;
</span><span class="HDDeleted">61: </span><span class="HDDeleted">import java.util.Iterator;
</span><span class="HDDeleted">62: </span><span class="HDDeleted">import java.util.TreeSet;
</span><span class="HDDeleted">63: </span><span class="HDDeleted">
</span>64: /**
65:  *  Basic implementation of &lt;code&gt;Geometry&lt;/code&gt;. &lt;P&gt;
66:  *
67:  *  &lt;code&gt;clone&lt;/code&gt; returns a deep copy of the object.
68:  *
69:  *  &lt;H3&gt;Binary Predicates&lt;/H3&gt;<a name="diff" id="c6"><span class="HDDeleted"> B</span></a>
<span class="HDDeleted">70: </span><span class="HDDeleted"> *  ecause it is not clear at this time what semantics for spatial
</span><span class="HDAdded">71: </span><span class="HDAdded"> * Because it is not clear at this time
</span><span class="HDAdded">72: </span><span class="HDAdded"> * what semantics for spatial
</span>73:  *  analysis methods involving &lt;code&gt;GeometryCollection&lt;/code&gt;s would be useful,
74:  *  &lt;code&gt;GeometryCollection&lt;/code&gt;s are not supported as arguments to binary
75:  *  predicates (other than &lt;code&gt;convexHull&lt;/code&gt;) or the &lt;code&gt;relate&lt;/code&gt;
76:  *  method.
77:  *
78:  *  &lt;H3&gt;Set-Theoretic Methods&lt;/H3&gt;
79:  *
80:  *  The spatial analysis methods will
81:  *  return the most specific class possible to represent the result. If the
82:  *  result is homogeneous, a &lt;code&gt;Point&lt;/code&gt;, &lt;code&gt;LineString&lt;/code&gt;, or
83:  *  &lt;code&gt;Polygon&lt;/code&gt; will be returned if the result contains a single
84:  *  element; otherwise, a &lt;code&gt;MultiPoint&lt;/code&gt;, &lt;code&gt;MultiLineString&lt;/code&gt;,
85:  *  or &lt;code&gt;MultiPolygon&lt;/code&gt; will be returned. If the result is
86:  *  heterogeneous a &lt;code&gt;GeometryCollection&lt;/code&gt; will be returned. &lt;P&gt;
87:  *
88:  *  Because it is not clear at this time what semantics for set-theoretic
89:  *  methods involving &lt;code&gt;GeometryCollection&lt;/code&gt;s would be useful,<a name="diff" id="c7"><span class="HDDeleted"> &lt;code&gt;GeometryCollections&lt;/code&gt;</span></a>
<span class="HDAdded">90: </span><span class="HDAdded"> * &lt;code&gt;GeometryCollections&lt;/code&gt;
</span>91:  *  are not supported as arguments to the set-theoretic methods.
92:  *
93:  *  &lt;H4&gt;Representation of Computed Geometries &lt;/H4&gt;
94:  *
95:  *  The SFS states that the result
96:  *  of a set-theoretic method is the "point-set" result of the usual
97:  *  set-theoretic definition of the operation (SFS 3.2.21.1). However, there are
98:  *  sometimes many ways of representing a point set as a &lt;code&gt;Geometry&lt;/code&gt;.
99:  *  &lt;P&gt;
100:     *
101:     *  The SFS does not specify an unambiguous representation of a given point set
102:     *  returned from a spatial analysis method. One goal of JTS is to make this
103:     *  specification precise and unambiguous. JTS will use a canonical form for
104:     *  &lt;code&gt;Geometry&lt;/code&gt;s returned from spatial analysis methods. The canonical
105:     *  form is a &lt;code&gt;Geometry&lt;/code&gt; which is simple and noded:
106:     *  &lt;UL&gt;
107:     *    &lt;LI&gt; Simple means that the Geometry returned will be simple according to
108:     *    the JTS definition of &lt;code&gt;isSimple&lt;/code&gt;.
109:     *    &lt;LI&gt; Noded applies only to overlays involving &lt;code&gt;LineString&lt;/code&gt;s. It
110:     *    means that all intersection points on &lt;code&gt;LineString&lt;/code&gt;s will be
111:     *    present as endpoints of &lt;code&gt;LineString&lt;/code&gt;s in the result.
112:     *  &lt;/UL&gt;
113:     *  This definition implies that non-simple geometries which are arguments to
114:     *  spatial analysis methods must be subjected to a line-dissolve process to
115:     *  ensure that the results are simple.
116:     *
117:     *  &lt;H4&gt; Constructed Points And The Precision Model &lt;/H4&gt;
118:     *
119:     *  The results computed by the set-theoretic methods may
120:     *  contain constructed points which are not present in the input &lt;code&gt;Geometry&lt;/code&gt;
121:     *  s. These new points arise from intersections between line segments in the
122:     *  edges of the input &lt;code&gt;Geometry&lt;/code&gt;s. In the general case it is not
123:     *  possible to represent constructed points exactly. This is due to the fact
124:     *  that the coordinates of an intersection point may contain twice as many bits
125:     *  of precision as the coordinates of the input line segments. In order to
126:     *  represent these constructed points explicitly, JTS must truncate them to fit
127:     *  the &lt;code&gt;PrecisionModel&lt;/code&gt;. &lt;P&gt;
128:     *
129:     *  Unfortunately, truncating coordinates moves them slightly. Line segments
130:     *  which would not be coincident in the exact result may become coincident in
131:     *  the truncated representation. This in turn leads to "topology collapses" --
132:     *  situations where a computed element has a lower dimension than it would in
133:     *  the exact result. &lt;P&gt;
134:     *
135:     *  When JTS detects topology collapses during the computation of spatial
136:     *  analysis methods, it will throw an exception. If possible the exception will
137:     *  report the location of the collapse.
138:     *
139:     *@version 1.<a name="diff" id="c8"><span class="HDDeleted">2</span></a><span class="HDAdded">3</span>
140:     */
141:    public abstract class Geometry<a name="diff" id="c9"><span class="HDDeleted"> implements SFSGeometry, Cloneable, Comparable {</span></a>
<span class="HDAdded">142:    </span><span class="HDAdded">    implements SFSGeometry, Cloneable, Comparable, Serializable {
</span>143:    
144:      /**
145:       *  Algorithms for computational geometry.
146:       */
147:      protected static CGAlgorithms cgAlgorithms = new RobustCGAlgorithms();
148:      /**
149:       *  The specification of the grid of allowable points for this &lt;code&gt;Geometry&lt;/code&gt;
150:       *  .
151:       */
152:      protected PrecisionModel precisionModel;
153:      /**
154:       *  The ID of the Spatial Reference System used by this &lt;code&gt;Geometry&lt;/code&gt;
155:       *  .
156:       */
157:      protected int SRID;
158:    
159:      /**
160:       *  The bounding box of this &lt;code&gt;Geometry&lt;/code&gt;.
161:       */
162:      protected Envelope envelope;
163:    
164:      private final static Class[] sortedClasses = new Class[]{
165:          Point.class,
166:          MultiPoint.class,
167:          LineString.class,
168:          LinearRing.class,
169:          MultiLineString.class,
170:          Polygon.class,
171:          MultiPolygon.class,
172:          GeometryCollection.class
173:          };
174:    
175:      private final static GeometryComponentFilter geometryChangedFilter = new GeometryComponentFilter() {
176:        public void filter(Geometry geom) {
177:          geom.geometryChangedAction();
178:        }
179:      };
180:    
181:      /**
182:       *  Constructs a &lt;code&gt;Geometry&lt;/code&gt;.
183:       *
184:       *@param  precisionModel  the specification of the grid of allowable points
185:       *      for this &lt;code&gt;Geometry&lt;/code&gt;
186:       *@param  SRID            the ID of the Spatial Reference System used by this
187:       *      &lt;code&gt;Geometry&lt;/code&gt;
188:       */
189:      public Geometry(PrecisionModel precisionModel, int SRID) {
190:        this.precisionModel = precisionModel;
191:        this.SRID = SRID;
192:      }
193:    
194:      /**
195:       *  Returns the name of this object's &lt;code&gt;com.vivid.jts.geom&lt;/code&gt;
196:       *  interface.
197:       *
198:       *@return    the name of this &lt;code&gt;Geometry&lt;/code&gt;s most specific &lt;code&gt;com.vividsolutions.jts.geom&lt;/code&gt;
199:       *      interface
200:       */
201:      //I wonder if we need this method, now that we have renamed the classes to
202:      //what their old interfaces were named. Now we can perhaps simply use
203:      //getClass().getName(). Who calls this method anyway? [Jon Aquino]
204:      public abstract String getGeometryType();
205:    
206:      /**
207:       *  Returns true if the array contains any non-empty &lt;code&gt;Geometry&lt;/code&gt;s.
208:       *
209:       *@param  geometries  an array of &lt;code&gt;Geometry&lt;/code&gt;s; no elements may be
210:       *      &lt;code&gt;null&lt;/code&gt;
211:       *@return             &lt;code&gt;true&lt;/code&gt; if any of the &lt;code&gt;Geometry&lt;/code&gt;s
212:       *      &lt;code&gt;isEmpty&lt;/code&gt; methods return &lt;code&gt;false&lt;/code&gt;
213:       */
214:      protected static boolean hasNonEmptyElements(Geometry[] geometries) {
215:        for (int i = 0; i &lt; geometries.length; i++) {
216:          if (!geometries[i].isEmpty()) {
217:            return true;
218:          }
219:        }
220:        return false;
221:      }
222:    
223:      /**
224:       *  Returns true if the array contains any &lt;code&gt;null&lt;/code&gt; elements.
225:       *
226:       *@param  array  an array to validate
227:       *@return        &lt;code&gt;true&lt;/code&gt; if any of &lt;code&gt;array&lt;/code&gt;s elements are
228:       *      &lt;code&gt;null&lt;/code&gt;
229:       */
230:      protected static boolean hasNullElements(Object[] array) {
231:        for (int i = 0; i &lt; array.length; i++) {
232:          if (array[i] == null) {
233:            return true;
234:          }
235:        }
236:        return false;
237:      }
238:    
<a name="diff" id="c10"><span class="HDDeleted">239:      /**
240:       *  Flips the positions of the elements in the array so that the last is
241:       *  first.
242:       *
243:       *@param  coordinates  the array to rearrange
244:       */
245:      protected static void reversePointOrder(Coordinate[] coordinates) {
246:        Coordinate[] newCoordinates = new Coordinate[coordinates.length];
247:        for (int i = 0; i &lt; coordinates.length; i++) {
248:          newCoordinates[i] = coordinates[coordinates.length - 1 - i];
249:        }
250:        System.arraycopy(newCoordinates, 0, coordinates, 0, coordinates.length);
251:      }
252:    
253:      /**
254:       *  Returns the minimum coordinate, using the usual lexicographic comparison.
255:       *
256:       *@param  coordinates  the array to search
257:       *@return              the minimum coordinate in the array, found using &lt;code&gt;compareTo&lt;/code&gt;
258:       */
259:      protected static Coordinate minCoordinate(Coordinate[] coordinates) {
260:        TreeSet sortedSet = new TreeSet(Arrays.asList(coordinates));
261:        return (Coordinate) sortedSet.first();
262:      }
</span></a>263:    
264:      /**
265:       *  Shifts the positions of the coordinates until &lt;code&gt;firstCoordinate&lt;/code&gt;
266:       *  is first.
267:       *
268:       *@param  coordinates      the array to rearrange
269:       *@param  firstCoordinate  the coordinate to make first
270:       */
<a name="diff" id="c11"><span class="HDAdded">240:      /*
</span></a>271:      protected static void scroll(Coordinate[] coordinates, Coordinate firstCoordinate) {
272:        int i = indexOf(firstCoordinate, coordinates);
273:        Assert.isTrue(i &gt; -1);
274:        Coordinate[] newCoordinates = new Coordinate[coordinates.length];
275:        System.arraycopy(coordinates, i, newCoordinates, 0, coordinates.length - i);
276:        System.arraycopy(coordinates, 0, newCoordinates, coordinates.length - i, i);
277:        System.arraycopy(newCoordinates, 0, coordinates, 0, coordinates.length);
278:      }
<a name="diff" id="c12"><span class="HDAdded">249:      */
</span></a>279:    
280:      /**
281:       *  Returns the index of &lt;code&gt;coordinate&lt;/code&gt; in &lt;code&gt;coordinates&lt;/code&gt;.
282:       *  The first position is 0; the second, 1; etc.
283:       *
284:       *@param  coordinate   the &lt;code&gt;Coordinate&lt;/code&gt; to search for
285:       *@param  coordinates  the array to search
286:       *@return              the position of &lt;code&gt;coordinate&lt;/code&gt;, or -1 if it is
287:       *      not found
288:       */
<a name="diff" id="c13"><span class="HDAdded">260:      /*
</span></a>289:      protected static int indexOf(Coordinate coordinate, Coordinate[] coordinates) {
290:        for (int i = 0; i &lt; coordinates.length; i++) {
291:          if (coordinate.equals(coordinates[i])) {
292:            return i;
293:          }
294:        }
295:        return -1;
296:      }
<a name="diff" id="c14"><span class="HDAdded">269:    */
</span></a>297:    
298:      /**
299:       *  Returns the ID of the Spatial Reference System used by the &lt;code&gt;Geometry&lt;/code&gt;.
300:       *  &lt;P&gt;
301:       *
302:       *  JTS supports Spatial Reference System information in the simple way
303:       *  defined in the SFS. A Spatial Reference System ID (SRID) is present in
304:       *  each &lt;code&gt;Geometry&lt;/code&gt; object. &lt;code&gt;Geometry&lt;/code&gt; provides basic
305:       *  accessor operations for this field, but no others. The SRID is represented
306:       *  as an integer.
307:       *
308:       *@return    the ID of the coordinate space in which the &lt;code&gt;Geometry&lt;/code&gt;
309:       *      is defined.
310:       */
311:      public int getSRID() {
312:        return SRID;
313:      }
314:      /**
315:       *  Sets the ID of the Spatial Reference System used by the &lt;code&gt;Geometry&lt;/code&gt;.
316:       */
317:      public void setSRID(int SRID) {
318:        this.SRID = SRID;
319:      }
320:    
321:      /**
322:       *  Returns the &lt;code&gt;PrecisionModel&lt;/code&gt; used by the &lt;code&gt;Geometry&lt;/code&gt;.
323:       *
324:       *@return    the specification of the grid of allowable points, for this
325:       *      &lt;code&gt;Geometry&lt;/code&gt; and all other &lt;code&gt;Geometry&lt;/code&gt;s
326:       */
327:      public PrecisionModel getPrecisionModel() {
328:        return precisionModel;
329:      }
330:    
331:      /**
332:       *  Returns a vertex of this &lt;code&gt;Geometry&lt;/code&gt;.
333:       *
334:       *@return    a {@link Coordinate} which is a vertex of this &lt;code&gt;Geometry&lt;/code&gt;.
335:       *          Returns &lt;code&gt;null&lt;/code&gt; if this Geometry is empty
336:       */
337:      public abstract Coordinate getCoordinate();
338:      /**
339:       *  Returns this &lt;code&gt;Geometry&lt;/code&gt; s vertices. If you modify the coordinates
340:       *  in this array, be sure to call #geometryChanged afterwards.
341:       *  The &lt;code&gt;Geometry&lt;/code&gt;s contained by composite &lt;code&gt;Geometry&lt;/code&gt;s
342:       *  must be Geometry's; that is, they must implement &lt;code&gt;getCoordinates&lt;/code&gt;.
343:       *
344:       *@return    the vertices of this &lt;code&gt;Geometry&lt;/code&gt;
345:       */
346:      public abstract Coordinate[] getCoordinates();
347:    
348:      /**
349:       *  Returns the count of this &lt;code&gt;Geometry&lt;/code&gt;s vertices. The &lt;code&gt;Geometry&lt;/code&gt;
350:       *  s contained by composite &lt;code&gt;Geometry&lt;/code&gt;s must be
351:       *  Geometry's; that is, they must implement &lt;code&gt;getNumPoints&lt;/code&gt;
352:       *
353:       *@return    the number of vertices in this &lt;code&gt;Geometry&lt;/code&gt;
354:       */
355:      public abstract int getNumPoints();
356:    
357:      /**
358:       *  Returns false if the &lt;code&gt;Geometry&lt;/code&gt; not simple.
359:       *  Subclasses provide their own definition of "simple". If
360:       *  this &lt;code&gt;Geometry&lt;/code&gt; is empty, returns &lt;code&gt;true&lt;/code&gt;. &lt;P&gt;
361:       *
362:       *  In general, the SFS specifications of simplicity seem to follow the
363:       *  following rule:
364:       *  &lt;UL&gt;
365:       *    &lt;LI&gt; A Geometry is simple iff the only self-intersections are at
366:       *    boundary points.
367:       *  &lt;/UL&gt;
368:       *  For all empty &lt;code&gt;Geometry&lt;/code&gt;s, &lt;code&gt;isSimple&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt;.
369:       *
370:       *@return    &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Geometry&lt;/code&gt; has any points of
371:       *      self-tangency, self-intersection or other anomalous points
372:       */
373:      public abstract boolean isSimple();
374:      /**
375:       *  Returns false if the &lt;code&gt;Geometry&lt;/code&gt; is invlaid.
376:       *  Subclasses provide their own definition of "valid". If
377:       *  this &lt;code&gt;Geometry&lt;/code&gt; is empty, returns &lt;code&gt;true&lt;/code&gt;.
378:       *
379:       *@return    &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Geometry&lt;/code&gt; is valid
380:       */
381:      public boolean isValid()
382:      {
383:        IsValidOp isValidOp = new IsValidOp(this);
384:        return isValidOp.isValid();
385:      }
386:    
387:      /**
388:       *  Returns whether or not the set of points in this &lt;code&gt;Geometry&lt;/code&gt; is
389:       *  empty.
390:       *
391:       *@return    &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Geometry&lt;/code&gt; equals the empty
392:       *      geometry
393:       */
394:      public abstract boolean isEmpty();
395:    
396:      /**
397:       *  Returns the minimum distance between this &lt;code&gt;Geometry&lt;/code&gt;
398:       *  and the &lt;code&gt;Geometry&lt;/code&gt; g
399:       *
400:       *@param  g  the &lt;code&gt;Geometry&lt;/code&gt; from which to compute the distance
401:       */
402:      public double distance(Geometry g)
403:      {
404:        return DistanceOp.distance(this, g);
405:      }
406:    
407:      /**
<a name="diff" id="c15"><span class="HDAdded">381:       * Tests whether the distance from this &lt;code&gt;Geometry&lt;/code&gt;
382:       * to another is less than or equal to a specified value.
383:       *
384:       * @param geom the Geometry to check the distance to
385:       * @param distance the distance value to compare
386:       * @return &lt;code&gt;true&lt;/code&gt; if the geometries are less than &lt;code&gt;distance&lt;/code&gt; apart.
387:       */
388:      public boolean isWithinDistance(Geometry geom, double distance)
389:      {
390:        double envDist = getEnvelopeInternal().distance(geom.getEnvelopeInternal());
391:        if (envDist &gt; distance)
392:          return false;
393:        // NOTE: this could be implemented more efficiently
394:        double geomDist = this.distance(geom);
395:        if (geomDist &gt; distance)
396:          return false;
397:        return true;
398:      }
399:      /**
</span></a>408:       *  Returns the area of this &lt;code&gt;Geometry&lt;/code&gt;.
409:       *  Areal Geometries have a non-zero area.
410:       *  They override this function to compute the area.
411:       *  Others return 0.0
412:       *
413:       *@return the area of the Geometry
414:       */
415:      public double getArea()
416:      {
417:        return 0.0;
418:      }
419:    
420:      /**
421:       *  Returns the length of this &lt;code&gt;Geometry&lt;/code&gt;.
422:       *  Linear geometries return their length.
423:       *  Areal geometries return their perimeter.
424:       *  They override this function to compute the area.
425:       *  Others return 0.0
426:       *
427:       *@return the length of the Geometry
428:       */
429:      public double getLength()
430:      {
431:        return 0.0;
432:      }
433:    
434:      /**
<a name="diff" id="c16"><span class="HDAdded">427:       * Computes the centroid of this &lt;code&gt;Geometry&lt;/code&gt;.
428:       * The centroid
429:       * is equal to the centroid of the set of component Geometrys of highest
430:       * dimension (since the lower-dimension geometries contribute zero
431:       * "weight" to the centroid)
432:       *
433:       * @return a {@link Point} which is the centroid of this Geometry
434:       */
435:      public Point getCentroid()
436:      {
437:        Coordinate centPt = null;
438:        int dim = getDimension();
439:        if (dim == 0) {
440:          CentroidPoint cent = new CentroidPoint();
441:          cent.add(this);
442:          centPt = cent.getCentroid();
443:        }
444:        else if (dim == 1) {
445:          CentroidLine cent = new CentroidLine();
446:          cent.add(this);
447:          centPt = cent.getCentroid();
448:        }
449:        else {
450:          CentroidArea cent = new CentroidArea();
451:          cent.add(this);
452:          centPt = cent.getCentroid();
453:        }
454:        return GeometryFactory.createPointFromInternalCoord(centPt, this);
455:    
456:      }
457:      /**
458:       * Computes an interior point of this &lt;code&gt;Geometry&lt;/code&gt;.
459:       * An interior point is guaranteed to lie in the interior of the Geometry,
460:       * if it possible to calculate such a point exactly. Otherwise,
461:       * the point may lie on the boundary of the geometry.
462:       *
463:       * @return a {@link Point} which is in the interior of this Geometry
464:       */
465:      public Point getInteriorPoint()
466:      {
467:        Coordinate interiorPt = null;
468:        int dim = getDimension();
469:        if (dim == 0) {
470:          InteriorPointPoint intPt = new InteriorPointPoint(this);
471:          interiorPt = intPt.getInteriorPoint();
472:        }
473:        else if (dim == 1) {
474:          InteriorPointLine intPt = new InteriorPointLine(this);
475:          interiorPt = intPt.getInteriorPoint();
476:        }
477:        else {
478:          InteriorPointArea intPt = new InteriorPointArea(this);
479:          interiorPt = intPt.getInteriorPoint();
480:        }
481:        return GeometryFactory.createPointFromInternalCoord(interiorPt, this);
482:      }
483:    
484:      /**
</span></a>435:       *  Returns the dimension of this &lt;code&gt;Geometry&lt;/code&gt;.
436:       *
437:       *@return    the dimension of the class implementing this interface, whether
438:       *      or not this object is the empty geometry
439:       */
440:      public abstract int getDimension();
441:      /**
442:       *  Returns the boundary, or the empty geometry if this &lt;code&gt;Geometry&lt;/code&gt;
443:       *  is empty. For a discussion of this function, see the OpenGIS Simple
444:       *  Features Specification. As stated in SFS Section 2.1.13.1, "the boundary
445:       *  of a Geometry is a set of Geometries of the next lower dimension."
446:       *
447:       *@return    the closure of the combinatorial boundary of this &lt;code&gt;Geometry&lt;/code&gt;
448:       */
449:      public abstract Geometry getBoundary();
450:    
451:      /**
452:       *  Returns the dimension of this &lt;code&gt;Geometry&lt;/code&gt;s inherent boundary.
453:       *
454:       *@return    the dimension of the boundary of the class implementing this
455:       *      interface, whether or not this object is the empty geometry. Returns
456:       *      &lt;code&gt;Dimension.FALSE&lt;/code&gt; if the boundary is the empty geometry.
457:       */
458:      public abstract int getBoundaryDimension();
459:    
460:      /**
461:       *  Returns this &lt;code&gt;Geometry&lt;/code&gt;s bounding box. If this &lt;code&gt;Geometry&lt;/code&gt;
462:       *  is the empty geometry, returns an empty &lt;code&gt;Point&lt;/code&gt;. If the &lt;code&gt;Geometry&lt;/code&gt;
463:       *  is a point, returns a non-empty &lt;code&gt;Point&lt;/code&gt;. Otherwise, returns a
464:       *  &lt;code&gt;Polygon&lt;/code&gt; whose points are (minx, miny), (maxx, miny), (maxx,
465:       *  maxy), (minx, maxy), (minx, miny).
466:       *
467:       *@return    an empty &lt;code&gt;Point&lt;/code&gt; (for empty &lt;code&gt;Geometry&lt;/code&gt;s), a
468:       *      &lt;code&gt;Point&lt;/code&gt; (for &lt;code&gt;Point&lt;/code&gt;s) or a &lt;code&gt;Polygon&lt;/code&gt;
469:       *      (in all other cases)
470:       */
471:      public Geometry getEnvelope() {
472:        return GeometryFactory.toGeometry(getEnvelopeInternal(), precisionModel,
473:            SRID);
474:      }
475:    
476:      /**
477:       *  Returns the minimum and maximum x and y values in this &lt;code&gt;Geometry&lt;/code&gt;
478:       *  , or a null &lt;code&gt;Envelope&lt;/code&gt; if this &lt;code&gt;Geometry&lt;/code&gt; is empty.
479:       *
480:       *@return    this &lt;code&gt;Geometry&lt;/code&gt;s bounding box; if the &lt;code&gt;Geometry&lt;/code&gt;
481:       *      is empty, &lt;code&gt;Envelope#isNull&lt;/code&gt; will return &lt;code&gt;true&lt;/code&gt;
482:       */
483:      public Envelope getEnvelopeInternal() {
484:        if (envelope == null) {
485:          envelope = computeEnvelopeInternal();
486:        }
487:        return envelope;
488:      }
489:    
490:      /**
491:       * Notifies this Geometry that its Coordinates have been changed by an external
492:       * party (using a CoordinateFilter, for example). The Geometry will flush
493:       * and/or update any information it has cached (such as its {@link Envelope} ).
494:       */
495:      public void geometryChanged() {
496:        apply(geometryChangedFilter);
497:      }
498:    
499:      /**
500:       * Notifies this Geometry that its Coordinates have been changed by an external
501:       * party. When #geometryChanged is called, this method will be called for
502:       * this Geometry and its component Geometries.
503:       * @see #apply(GeometryComponentFilter)
504:       */
505:      protected void geometryChangedAction() {
506:        envelope = null;
507:      }
508:    
509:      /**
510:       *  Returns &lt;code&gt;true&lt;/code&gt; if the DE-9IM intersection matrix for the two
511:       *  &lt;code&gt;Geometry&lt;/code&gt;s is FF*FF****.
512:       *
513:       *@param  other  the &lt;code&gt;Geometry&lt;/code&gt; with which to compare this &lt;code&gt;Geometry&lt;/code&gt;
514:       *@return        &lt;code&gt;true&lt;/code&gt; if the two &lt;code&gt;Geometry&lt;/code&gt;s are
515:       *      disjoint
516:       */
517:      public boolean disjoint(Geometry g) {
518:        return relate(g).isDisjoint();
519:      }
520:    
521:      /**
522:       *  Returns &lt;code&gt;true&lt;/code&gt; if the DE-9IM intersection matrix for the two
523:       *  &lt;code&gt;Geometry&lt;/code&gt;s is FT*******, F**T***** or F***T****.
524:       *
525:       *@param  other  the &lt;code&gt;Geometry&lt;/code&gt; with which to compare this &lt;code&gt;Geometry&lt;/code&gt;
526:       *@return        &lt;code&gt;true&lt;/code&gt; if the two &lt;code&gt;Geometry&lt;/code&gt;s touch;
527:       *      Returns false if both &lt;code&gt;Geometry&lt;/code&gt;s are points
528:       */
529:      public boolean touches(Geometry g) {
530:        return relate(g).isTouches(getDimension(), g.getDimension());
531:      }
532:    
533:      /**
534:       *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;disjoint&lt;/code&gt; returns false.
535:       *
536:       *@param  other  the &lt;code&gt;Geometry&lt;/code&gt; with which to compare this &lt;code&gt;Geometry&lt;/code&gt;
537:       *@return        &lt;code&gt;true&lt;/code&gt; if the two &lt;code&gt;Geometry&lt;/code&gt;s intersect
538:       */
539:      public boolean intersects(Geometry g) {
540:        return relate(g).isIntersects();
541:      }
542:    
543:      /**
544:       *  Returns &lt;code&gt;true&lt;/code&gt; if the DE-9IM intersection matrix for the two
545:       *  &lt;code&gt;Geometry&lt;/code&gt;s is
546:       *  &lt;UL&gt;
547:       *    &lt;LI&gt; T*T****** (for a point and a curve, a point and an area or a line
548:       *    and an area)
549:       *    &lt;LI&gt; 0******** (for two curves)
550:       *  &lt;/UL&gt;
551:       *  .
552:       *
553:       *@param  other  the &lt;code&gt;Geometry&lt;/code&gt; with which to compare this &lt;code&gt;Geometry&lt;/code&gt;
554:       *@return        &lt;code&gt;true&lt;/code&gt; if the two &lt;code&gt;Geometry&lt;/code&gt;s cross.
555:       *      For this function to return &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;Geometry&lt;/code&gt;
556:       *      s must be a point and a curve; a point and a surface; two curves; or a
557:       *      curve and a surface.
558:       */
559:      public boolean crosses(Geometry g) {
560:        return relate(g).isCrosses(getDimension(), g.getDimension());
561:      }
562:    
563:      /**
564:       *  Returns &lt;code&gt;true&lt;/code&gt; if the DE-9IM intersection matrix for the two
565:       *  &lt;code&gt;Geometry&lt;/code&gt;s is T*F**F***.
566:       *
567:       *@param  other  the &lt;code&gt;Geometry&lt;/code&gt; with which to compare this &lt;code&gt;Geometry&lt;/code&gt;
568:       *@return        &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Geometry&lt;/code&gt; is within
569:       *      &lt;code&gt;other&lt;/code&gt;
570:       */
571:      public boolean within(Geometry g) {
572:        return relate(g).isWithin();
573:      }
574:    
575:      /**
576:       *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;other.within(this)&lt;/code&gt; returns
577:       *  &lt;code&gt;true&lt;/code&gt;.
578:       *
579:       *@param  other  the &lt;code&gt;Geometry&lt;/code&gt; with which to compare this &lt;code&gt;Geometry&lt;/code&gt;
580:       *@return        &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Geometry&lt;/code&gt; contains
581:       *      &lt;code&gt;other&lt;/code&gt;
582:       */
583:      public boolean contains(Geometry g) {
584:        return relate(g).isContains();
585:      }
586:    
587:      /**
588:       *  Returns &lt;code&gt;true&lt;/code&gt; if the DE-9IM intersection matrix for the two
589:       *  &lt;code&gt;Geometry&lt;/code&gt;s is
590:       *  &lt;UL&gt;
591:       *    &lt;LI&gt; T*T***T** (for two points or two surfaces)
592:       *    &lt;LI&gt; 1*T***T** (for two curves)
593:       *  &lt;/UL&gt;
594:       *  .
595:       *
596:       *@param  other  the &lt;code&gt;Geometry&lt;/code&gt; with which to compare this &lt;code&gt;Geometry&lt;/code&gt;
597:       *@return        &lt;code&gt;true&lt;/code&gt; if the two &lt;code&gt;Geometry&lt;/code&gt;s overlap.
598:       *      For this function to return &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;Geometry&lt;/code&gt;
599:       *      s must be two points, two curves or two surfaces.
600:       */
601:      public boolean overlaps(Geometry g) {
602:        return relate(g).isOverlaps(getDimension(), g.getDimension());
603:      }
604:    
605:      /**
606:       *  Returns &lt;code&gt;true&lt;/code&gt; if the elements in the DE-9IM intersection
607:       *  matrix for the two &lt;code&gt;Geometry&lt;/code&gt;s match the elements in &lt;code&gt;intersectionPattern&lt;/code&gt;
608:       *  , which may be:
609:       *  &lt;UL&gt;
610:       *    &lt;LI&gt; 0
611:       *    &lt;LI&gt; 1
612:       *    &lt;LI&gt; 2
613:       *    &lt;LI&gt; T ( = 0, 1 or 2)
614:       *    &lt;LI&gt; F ( = -1)
615:       *    &lt;LI&gt; * ( = -1, 0, 1 or 2)
616:       *  &lt;/UL&gt;
617:       *  For more information on the DE-9IM, see the OpenGIS Simple Features
618:       *  Specification.
619:       *
620:       *@param  other                the &lt;code&gt;Geometry&lt;/code&gt; with which to compare
621:       *      this &lt;code&gt;Geometry&lt;/code&gt;
622:       *@param  intersectionPattern  the pattern against which to check the
623:       *      intersection matrix for the two &lt;code&gt;Geometry&lt;/code&gt;s
624:       *@return                      &lt;code&gt;true&lt;/code&gt; if the DE-9IM intersection
625:       *      matrix for the two &lt;code&gt;Geometry&lt;/code&gt;s match &lt;code&gt;intersectionPattern&lt;/code&gt;
626:       */
627:      public boolean relate(Geometry g, String intersectionPattern) {
628:        return relate(g).matches(intersectionPattern);
629:      }
630:    
631:      /**
632:       *  Returns the DE-9IM intersection matrix for the two &lt;code&gt;Geometry&lt;/code&gt;s.
633:       *
634:       *@param  other  the &lt;code&gt;Geometry&lt;/code&gt; with which to compare this &lt;code&gt;Geometry&lt;/code&gt;
635:       *@return        a matrix describing the intersections of the interiors,
636:       *      boundaries and exteriors of the two &lt;code&gt;Geometry&lt;/code&gt;s
637:       */
638:      public IntersectionMatrix relate(Geometry g) {
639:        checkNotGeometryCollection(this);
640:        checkNotGeometryCollection(g);
<a name="diff" id="c17"><span class="HDDeleted">641:        checkEqualSRID(g);
642:        checkEqualPrecisionModel(g);
</span></a>643:        return RelateOp.relate(this, g);
644:      }
645:    
646:      /**
647:       *  Returns &lt;code&gt;true&lt;/code&gt; if the DE-9IM intersection matrix for the two
648:       *  &lt;code&gt;Geometry&lt;/code&gt;s is T*F**FFF*.
649:       *
650:       *@param  other  the &lt;code&gt;Geometry&lt;/code&gt; with which to compare this &lt;code&gt;Geometry&lt;/code&gt;
651:       *@return        &lt;code&gt;true&lt;/code&gt; if the two &lt;code&gt;Geometry&lt;/code&gt;s are equal
652:       */
653:      public boolean equals(Geometry g) {
654:        return relate(g).isEquals(getDimension(), g.getDimension());
655:      }
656:    
657:      //&lt;&lt;PERHAPS:DESIGN&gt;&gt; Override Object#equals [Jon Aquino]
658:    
659:      public String toString() {
660:        return toText();
661:      }
662:    
663:      /**
664:       *  Returns the Well-known Text representation of this &lt;code&gt;Geometry&lt;/code&gt;.
665:       *  For a definition of the Well-known Text format, see the OpenGIS Simple
666:       *  Features Specification.
667:       *
668:       *@return    the Well-known Text representation of this &lt;code&gt;Geometry&lt;/code&gt;
669:       */
670:      public String toText() {
671:        WKTWriter writer = new WKTWriter();
672:        return writer.write(this);
673:      }
674:    
675:      /**
676:       *  Returns a buffer region around this &lt;code&gt;Geometry&lt;/code&gt; having the given
677:       *  width.
678:       * The buffer of a Geometry is the Minkowski sum of the Geometry with
679:       * a disc of radius &lt;code&gt;distance&lt;/code&gt;.
680:       *
681:       *@param  distance  the width of the buffer, interpreted according to the
682:       *      &lt;code&gt;PrecisionModel&lt;/code&gt; of the &lt;code&gt;Geometry&lt;/code&gt;
683:       *@return           all points whose distance from this &lt;code&gt;Geometry&lt;/code&gt;
684:       *      are less than or equal to &lt;code&gt;distance&lt;/code&gt;
685:       */
686:      public Geometry buffer(double distance) {
687:        return BufferOp.bufferOp(this, distance);
688:      }
689:    
690:      /**
<a name="diff" id="c18"><span class="HDAdded">739:       *  Returns a buffer region around this &lt;code&gt;Geometry&lt;/code&gt; having the given
740:       *  width and with a specified number of segments used to approximate curves.
741:       * The buffer of a Geometry is the Minkowski sum of the Geometry with
742:       * a disc of radius &lt;code&gt;distance&lt;/code&gt;.  Curves in the buffer polygon are
743:       * approximated with line segments.  This method allows specifying the
744:       * accuracy of that approximation.
745:       *
746:       *@param  distance  the width of the buffer, interpreted according to the
747:       *      &lt;code&gt;PrecisionModel&lt;/code&gt; of the &lt;code&gt;Geometry&lt;/code&gt;
748:       *@param quadrantSegments the number of segments to use to approximate a quadrant of a circle
749:       *@return           all points whose distance from this &lt;code&gt;Geometry&lt;/code&gt;
750:       *      are less than or equal to &lt;code&gt;distance&lt;/code&gt;
751:       */
752:      public Geometry buffer(double distance, int quadrantSegments) {
753:        return BufferOp.bufferOp(this, distance, quadrantSegments);
754:      }
755:    
756:      /**
</span></a>691:       *  Returns the smallest convex &lt;code&gt;Polygon&lt;/code&gt; that contains all the
692:       *  points in the &lt;code&gt;Geometry&lt;/code&gt;. This obviously applies only to &lt;code&gt;Geometry&lt;/code&gt;
693:       *  s which contain 3 or more points; the results for degenerate cases are
694:       *  specified as follows:
695:       *  &lt;TABLE&gt;
696:       *    &lt;TR&gt;
697:       *      &lt;TH&gt;    Number of &lt;code&gt;Point&lt;/code&gt;s in argument &lt;code&gt;Geometry&lt;/code&gt;   &lt;/TH&gt;
698:       *      &lt;TH&gt;    &lt;code&gt;Geometry&lt;/code&gt; class of result     &lt;/TH&gt;
699:       *    &lt;/TR&gt;
700:       *    &lt;TR&gt;
701:       *      &lt;TD&gt;        0      &lt;/TD&gt;
702:       *      &lt;TD&gt;        empty &lt;code&gt;GeometryCollection&lt;/code&gt;      &lt;/TD&gt;
703:       *    &lt;/TR&gt;
704:       *    &lt;TR&gt;  &lt;TD&gt;      1     &lt;/TD&gt;
705:       *      &lt;TD&gt;     &lt;code&gt;Point&lt;/code&gt;     &lt;/TD&gt;
706:       *    &lt;/TR&gt;
707:       *    &lt;TR&gt;
708:       *      &lt;TD&gt;      2     &lt;/TD&gt;
709:       *      &lt;TD&gt;     &lt;code&gt;LineString&lt;/code&gt;     &lt;/TD&gt;
710:       *    &lt;/TR&gt;
711:       *    &lt;TR&gt;
712:       *      &lt;TD&gt;       3 or more     &lt;/TD&gt;
713:       *      &lt;TD&gt;      &lt;code&gt;Polygon&lt;/code&gt;     &lt;/TD&gt;
714:       *    &lt;/TR&gt;
715:       *  &lt;/TABLE&gt;
716:       *
717:       *@return    the minimum-area convex polygon containing this &lt;code&gt;Geometry&lt;/code&gt;'
718:       *      s points
719:       */
720:      public Geometry convexHull() {
721:        return (new ConvexHull(cgAlgorithms)).getConvexHull(this);
722:      }
723:    
724:      /**
725:       *  Returns a &lt;code&gt;Geometry&lt;/code&gt; representing the points shared by this
726:       *  &lt;code&gt;Geometry&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.
727:       *
728:       *@param  other  the &lt;code&gt;Geometry&lt;/code&gt; with which to compute the
729:       *      intersection
730:       *@return        the points common to the two &lt;code&gt;Geometry&lt;/code&gt;s
731:       */
732:      public Geometry intersection(Geometry other) {
733:        checkNotGeometryCollection(this);
734:        checkNotGeometryCollection(other);
<a name="diff" id="c19"><span class="HDDeleted">735:        checkEqualSRID(other);
736:        checkEqualPrecisionModel(other);
</span></a>737:        return OverlayOp.overlayOp(this, other, OverlayOp.INTERSECTION);
738:      }
739:    
740:      /**
741:       *  Returns a &lt;code&gt;Geometry&lt;/code&gt; representing all the points in this &lt;code&gt;Geometry&lt;/code&gt;
742:       *  and &lt;code&gt;other&lt;/code&gt;.
743:       *
744:       *@param  other  the &lt;code&gt;Geometry&lt;/code&gt; with which to compute the union
745:       *@return        a set combining the points of this &lt;code&gt;Geometry&lt;/code&gt; and
746:       *      the points of &lt;code&gt;other&lt;/code&gt;
747:       */
748:      public Geometry union(Geometry other) {
749:        checkNotGeometryCollection(this);
750:        checkNotGeometryCollection(other);
<a name="diff" id="c20"><span class="HDDeleted">751:        checkEqualSRID(other);
752:        checkEqualPrecisionModel(other);
</span></a>753:        return OverlayOp.overlayOp(this, other, OverlayOp.UNION);
754:      }
755:    
756:      /**
757:       *  Returns a &lt;code&gt;Geometry&lt;/code&gt; representing the points making up this
758:       *  &lt;code&gt;Geometry&lt;/code&gt; that do not make up &lt;code&gt;other&lt;/code&gt;. This method
759:       *  returns the closure of the resultant &lt;code&gt;Geometry&lt;/code&gt;.
760:       *
761:       *@param  other  the &lt;code&gt;Geometry&lt;/code&gt; with which to compute the
762:       *      difference
763:       *@return        the point set difference of this &lt;code&gt;Geometry&lt;/code&gt; with
764:       *      &lt;code&gt;other&lt;/code&gt;
765:       */
766:      public Geometry difference(Geometry other) {
767:        checkNotGeometryCollection(this);
768:        checkNotGeometryCollection(other);
<a name="diff" id="c21"><span class="HDDeleted">769:        checkEqualSRID(other);
770:        checkEqualPrecisionModel(other);
</span></a>771:        return OverlayOp.overlayOp(this, other, OverlayOp.DIFFERENCE);
772:      }
773:    
774:      /**
775:       *  Returns a set combining the points in this &lt;code&gt;Geometry&lt;/code&gt; not in
776:       *  &lt;code&gt;other&lt;/code&gt;, and the points in &lt;code&gt;other&lt;/code&gt; not in this
777:       *  &lt;code&gt;Geometry&lt;/code&gt;. This method returns the closure of the resultant
778:       *  &lt;code&gt;Geometry&lt;/code&gt;.
779:       *
780:       *@param  other  the &lt;code&gt;Geometry&lt;/code&gt; with which to compute the symmetric
781:       *      difference
782:       *@return        the point set symmetric difference of this &lt;code&gt;Geometry&lt;/code&gt;
783:       *      with &lt;code&gt;other&lt;/code&gt;
784:       */
785:      public Geometry symDifference(Geometry other) {
786:        checkNotGeometryCollection(this);
787:        checkNotGeometryCollection(other);
<a name="diff" id="c22"><span class="HDDeleted">788:        checkEqualSRID(other);
789:        checkEqualPrecisionModel(other);
</span></a>790:        return OverlayOp.overlayOp(this, other, OverlayOp.SYMDIFFERENCE);
791:      }
792:    
793:      /**
794:       *  Returns true if the two &lt;code&gt;Geometry&lt;/code&gt;s <a name="diff" id="c23"><span class="HDDeleted">have the same class and</span></a><span class="HDAdded">are exactly equal,</span>
<span class="HDDeleted">795:    </span><span class="HDDeleted">   *  if the data which they store internally are equal. Stricter equality than
</span><span class="HDDeleted">796:       *  &lt;code&gt;equals&lt;/code&gt;. If this and the other &lt;code&gt;Geometry&lt;/code&gt;s are
</span><span class="HDAdded">853:    </span><span class="HDAdded">   * up to a specified tolerance.
</span><span class="HDAdded">854:       * Two Geometrys are exactly within a tolerance equal iff:
855:       * &lt;ul&gt;
856:       * &lt;li&gt;they have the same class
857:       * &lt;li&gt;they have the same values of Coordinates,
858:       * within the given tolerance distance, in their internal
859:       * Coordinate lists, in exactly the same order.
860:       * &lt;/ul&gt;
861:       * If this and the other &lt;code&gt;Geometry&lt;/code&gt;s are
862:       *  composites and any children are not &lt;code&gt;Geometry&lt;/code&gt;s, returns
863:       *  false.
864:       *
865:       *@param  other  the &lt;code&gt;Geometry&lt;/code&gt; with which to compare this &lt;code&gt;Geometry&lt;/code&gt;
866:       *@parm tolerance distance at or below which two Coordinates will be considered
867:       * equal
868:       *@return        &lt;code&gt;true&lt;/code&gt; if this and the other &lt;code&gt;Geometry&lt;/code&gt;
869:       *      are of the same class and have equal internal data.
870:       */
871:      public abstract boolean equalsExact(Geometry other, double tolerance);
872:    
873:      /**
874:       *  Returns true if the two &lt;code&gt;Geometry&lt;/code&gt;s are exactly equal.
875:       * Two Geometrys are exactly equal iff:
876:       * &lt;ul&gt;
877:       * &lt;li&gt;they have the same class
878:       * &lt;li&gt;they have the same values of Coordinates in their internal
879:       * Coordinate lists, in exactly the same order.
880:       * &lt;/ul&gt;
881:       * If this and the other &lt;code&gt;Geometry&lt;/code&gt;s are
</span>797:       *  composites and any children are not &lt;code&gt;Geometry&lt;/code&gt;s, returns
798:       *  false.
<a name="diff" id="c24"><span class="HDAdded">884:       * &lt;p&gt;
885:       *  This provides a stricter test of equality than
886:       *  &lt;code&gt;equals&lt;/code&gt;.
</span></a>799:       *
800:       *@param  other  the &lt;code&gt;Geometry&lt;/code&gt; with which to compare this &lt;code&gt;Geometry&lt;/code&gt;
801:       *@return        &lt;code&gt;true&lt;/code&gt; if this and the other &lt;code&gt;Geometry&lt;/code&gt;
802:       *      are of the same class and have equal internal data.
803:       */
<a name="diff" id="c25"><span class="HDDeleted">804:    </span></a><span class="HDDeleted">  public abstract boolean equalsExact(Geometry other);
</span><span class="HDAdded">805:    </span><span class="HDAdded">  public boolean equalsExact(Geometry other) { return equalsExact(other, 0); }
</span>806:    
807:      /**
808:       *  Performs an operation with or on this &lt;code&gt;Geometry&lt;/code&gt;'s
809:       *  coordinates.
810:       *
811:       *@param  filter  the filter to apply to this &lt;code&gt;Geometry&lt;/code&gt;'s
812:       *      coordinates
813:       */
814:      public abstract void apply(CoordinateFilter filter);
815:    
816:      /**
817:       *  Performs an operation with or on this &lt;code&gt;Geometry&lt;/code&gt; and its
818:       *  subelement &lt;code&gt;Geometry&lt;/code&gt;s (if any).
819:       *  Only GeometryCollections and subclasses
820:       *  have subelement <a name="diff" id="c26"><span class="HDDeleted">Geometrys</span></a><span class="HDAdded">Geometry's</span>.
821:       *
822:       *@param  filter  the filter to apply to this &lt;code&gt;Geometry&lt;/code&gt; (and
823:       *      its children, if it is a &lt;code&gt;GeometryCollection&lt;/code&gt;).
824:       */
825:      public abstract void apply(GeometryFilter filter);
826:    
827:      /**
828:       *  Performs an operation with or on this Geometry and its
829:       *  component <a name="diff" id="c27"><span class="HDDeleted">Geometrys</span></a><span class="HDAdded">Geometry's</span>.  Only GeometryCollections and
830:       *  Polygons have component <span class="HDDeleted">Geometrys</span><span class="HDAdded">Geometry's</span>; for Polygons they are the LinearRings
831:       *  of the shell and holes.
832:       *
833:       *@param  filter  the filter to apply to this &lt;code&gt;Geometry&lt;/code&gt;.
834:       */
835:      public abstract void apply(GeometryComponentFilter filter);
836:    
837:      public Object clone() {
838:        try {
839:          return super.clone();
840:        }
841:        catch (CloneNotSupportedException e) {
842:          Assert.shouldNeverReachHere();
843:          return null;
844:        }
845:      }
846:    
847:      /**
848:       *  Converts this &lt;code&gt;Geometry&lt;/code&gt; to &lt;b&gt;normal form&lt;/b&gt; (or &lt;b&gt;
849:       *  canonical form&lt;/b&gt; ). Normal form is a unique representation for &lt;code&gt;Geometry&lt;/code&gt;
850:       *  s. It can be used to test whether two &lt;code&gt;Geometry&lt;/code&gt;s are equal
851:       *  in a way that is independent of the ordering of the coordinates within
852:       *  them. Normal form equality is a stronger condition than topological
853:       *  equality, but weaker than pointwise equality. The definitions for normal
854:       *  form use the standard lexicographical ordering for coordinates. "Sorted in
855:       *  order of coordinates" means the obvious extension of this ordering to
856:       *  sequences of coordinates.
857:       */
858:      public abstract void normalize();
859:    
860:      /**
861:       *  Returns whether this &lt;code&gt;Geometry&lt;/code&gt; is greater than, equal to,
862:       *  or less than another &lt;code&gt;Geometry&lt;/code&gt;. &lt;P&gt;
863:       *
864:       *  If their classes are different, they are compared using the following
865:       *  ordering:
866:       *  &lt;UL&gt;
867:       *    &lt;LI&gt; Point (lowest)
868:       *    &lt;LI&gt; MultiPoint
869:       *    &lt;LI&gt; LineString
870:       *    &lt;LI&gt; LinearRing
871:       *    &lt;LI&gt; MultiLineString
872:       *    &lt;LI&gt; Polygon
873:       *    &lt;LI&gt; MultiPolygon
874:       *    &lt;LI&gt; GeometryCollection (highest)
875:       *  &lt;/UL&gt;
876:       *  If the two &lt;code&gt;Geometry&lt;/code&gt;s have the same class, their first
877:       *  elements are compared. If those are the same, the second elements are
878:       *  compared, etc.
879:       *
880:       *@param  o  a &lt;code&gt;Geometry&lt;/code&gt; with which to compare this &lt;code&gt;Geometry&lt;/code&gt;
881:       *@return    a positive number, 0, or a negative number, depending on whether
882:       *      this object is greater than, equal to, or less than &lt;code&gt;o&lt;/code&gt;, as
883:       *      defined in "Normal Form For Geometry" in the JTS Technical
884:       *      Specifications
885:       */
886:      public int compareTo(Object o) {
887:        Geometry other = (Geometry) o;
888:        if (getClassSortIndex() != other.getClassSortIndex()) {
889:          return getClassSortIndex() - other.getClassSortIndex();
890:        }
891:        if (isEmpty() &amp;&amp; other.isEmpty()) {
892:          return 0;
893:        }
894:        if (isEmpty()) {
895:          return -1;
896:        }
897:        if (other.isEmpty()) {
898:          return 1;
899:        }
900:        return compareToSameClass(o);
901:      }
902:    
903:      /**
904:       *  Returns whether the two &lt;code&gt;Geometry&lt;/code&gt;s are equal, from the point
905:       *  of view of the &lt;code&gt;equalsExact&lt;/code&gt; method. Called by &lt;code&gt;equalsExact&lt;/code&gt;
906:       *  . In general, two &lt;code&gt;Geometry&lt;/code&gt; classes are considered to be
907:       *  "equivalent" only if they are the same class. An exception is &lt;code&gt;LineString&lt;/code&gt;
908:       *  , which is considered to be equivalent to its subclasses.
909:       *
910:       *@param  other  the &lt;code&gt;Geometry&lt;/code&gt; with which to compare this &lt;code&gt;Geometry&lt;/code&gt;
911:       *      for equality
912:       *@return        &lt;code&gt;true&lt;/code&gt; if the classes of the two &lt;code&gt;Geometry&lt;/code&gt;
913:       *      s are considered to be equal by the &lt;code&gt;equalsExact&lt;/code&gt; method.
914:       */
915:      protected boolean isEquivalentClass(Geometry other) {
916:        return this.getClass().getName().equals(other.getClass().getName());
917:      }
918:    
919:      /**
920:       *  Throws an exception if &lt;code&gt;g&lt;/code&gt;'s class is &lt;code&gt;GeometryCollection&lt;/code&gt;
921:       *  . (Its subclasses do not trigger an exception).
922:       *
923:       *@param  g                          the &lt;code&gt;Geometry&lt;/code&gt; to check
924:       *@throws  IllegalArgumentException  if &lt;code&gt;g&lt;/code&gt; is a &lt;code&gt;GeometryCollection&lt;/code&gt;
925:       *      but not one of its subclasses
926:       */
927:      protected void checkNotGeometryCollection(Geometry g) {
928:        //Don't use instanceof because we want to allow subclasses
929:        if (g.getClass().getName().equals("com.vividsolutions.jts.geom.GeometryCollection")) {
930:          throw new IllegalArgumentException("This method does not support GeometryCollection arguments");
931:        }
932:      }
933:    
<a name="diff" id="c28"><span class="HDDeleted">934:      /**
935:       *  Throws an exception if the spatial reference IDs differ
936:       *
937:       *@param  other                         the &lt;code&gt;Geometry&lt;/code&gt; with which to compare this &lt;code&gt;Geometry&lt;/code&gt;
938:       *@throws  IllegalArgumentException  if the two &lt;code&gt;Geometry&lt;/code&gt;s have
939:       *different SRIDs
940:       */
941:      protected void checkEqualSRID(Geometry other) {
942:        if (SRID != other.getSRID()) {
943:          throw new IllegalArgumentException("Expected SRIDs to be equal, but they were not");
944:        }
945:      }
946:    
947:      /**
948:       *  Throws an exception if the &lt;code&gt;PrecisionModel&lt;/code&gt;s differ
949:       *
950:       *@param  other                         the &lt;code&gt;Geometry&lt;/code&gt; with which to compare this &lt;code&gt;Geometry&lt;/code&gt;
951:       *@throws  IllegalArgumentException  if the two &lt;code&gt;Geometry&lt;/code&gt;s have
952:       *unequal &lt;code&gt;PrecisionModel&lt;/code&gt;s
953:       */
954:      protected void checkEqualPrecisionModel(Geometry other) {
955:        if (! precisionModel.equals(other.getPrecisionModel())) {
956:          throw new IllegalArgumentException("Expected precision models to be equal, but they were not");
957:        }
958:      }
</span></a>959:    
960:      /**
961:       *  Returns the minimum and maximum x and y values in this &lt;code&gt;Geometry&lt;/code&gt;
962:       *  , or a null &lt;code&gt;Envelope&lt;/code&gt; if this &lt;code&gt;Geometry&lt;/code&gt; is empty.
963:       *  Unlike &lt;code&gt;getEnvelopeInternal&lt;/code&gt;, this method calculates the &lt;code&gt;Envelope&lt;/code&gt;
964:       *  each time it is called; &lt;code&gt;getEnvelopeInternal&lt;/code&gt; caches the result
965:       *  of this method.
966:       *
967:       *@return    this &lt;code&gt;Geometry&lt;/code&gt;s bounding box; if the &lt;code&gt;Geometry&lt;/code&gt;
968:       *      is empty, &lt;code&gt;Envelope#isNull&lt;/code&gt; will return &lt;code&gt;true&lt;/code&gt;
969:       */
970:      protected abstract Envelope computeEnvelopeInternal();
971:    
972:      /**
973:       *  Returns whether this &lt;code&gt;Geometry&lt;/code&gt; is greater than, equal to,
974:       *  or less than another &lt;code&gt;Geometry&lt;/code&gt; having the same class.
975:       *
976:       *@param  o  a &lt;code&gt;Geometry&lt;/code&gt; having the same class as this &lt;code&gt;Geometry&lt;/code&gt;
977:       *@return    a positive number, 0, or a negative number, depending on whether
978:       *      this object is greater than, equal to, or less than &lt;code&gt;o&lt;/code&gt;, as
979:       *      defined in "Normal Form For Geometry" in the JTS Technical
980:       *      Specifications
981:       */
982:      protected abstract int compareToSameClass(Object o);
983:    
984:      /**
985:       *  Returns the first non-zero result of &lt;code&gt;compareTo&lt;/code&gt; encountered as
986:       *  the two &lt;code&gt;Collection&lt;/code&gt;s are iterated over. If, by the time one of
987:       *  the iterations is complete, no non-zero result has been encountered,
988:       *  returns 0 if the other iteration is also complete. If &lt;code&gt;b&lt;/code&gt;
989:       *  completes before &lt;code&gt;a&lt;/code&gt;, a positive number is returned; if a
990:       *  before b, a negative number.
991:       *
992:       *@param  a  a &lt;code&gt;Collection&lt;/code&gt; of &lt;code&gt;Comparable&lt;/code&gt;s
993:       *@param  b  a &lt;code&gt;Collection&lt;/code&gt; of &lt;code&gt;Comparable&lt;/code&gt;s
994:       *@return    the first non-zero &lt;code&gt;compareTo&lt;/code&gt; result, if any;
995:       *      otherwise, zero
996:       */
997:      protected int compare(Collection a, Collection b) {
998:        Iterator i = a.iterator();
999:        Iterator j = b.iterator();
1000:       while (i.hasNext() &amp;&amp; j.hasNext()) {
1001:         Comparable aElement = (Comparable) i.next();
1002:         Comparable bElement = (Comparable) j.next();
1003:         int comparison = aElement.compareTo(bElement);
1004:         if (comparison != 0) {
1005:           return comparison;
1006:         }
1007:       }
1008:       if (i.hasNext()) {
1009:         return 1;
1010:       }
1011:       if (j.hasNext()) {
1012:         return -1;
1013:       }
1014:       return 0;
<a name="diff" id="c29"><span class="HDAdded">1077:     }
1078:   
1079:     protected boolean equal(Coordinate a, Coordinate b, double tolerance) {
1080:       if (tolerance == 0) { return a.equals(b); }
1081:       return a.distance(b) &lt;= tolerance;
</span></a>1015:     }
1016:   
1017:     private int getClassSortIndex() {
1018:       for (int i = 0; i &lt; sortedClasses.length; i++) {
1019:         if (sortedClasses[i].isInstance(this)) {
1020:           return i;
1021:         }
1022:       }
1023:       Assert.shouldNeverReachHere("Class not supported: " + this.getClass());
1024:       return -1;
1025:     }
1026:   /*
1027:     public Geometry changePrecision(PrecisionModel newPM)
1028:     {
1029:         //return OverlayGraph.reducePrecision(this, newPM);
1030:     }
1031:     */
1032:   
1033:   }
1034:   
</pre>
</body>
<SCRIPT LANGUAGE="JavaScript" TYPE="text/javascript">
<!--
var newWind;
function putJumpCode(){
	var cnt = 30;
	newWind.document.write('<html>\n');
	newWind.document.write('<title>HtmlDiff Navigation</title>\n');
	newWind.document.write('<body>\n');
	newWind.document.write('<form name="jump">\n');
	newWind.document.write('<input type="button" value=" |&lt; " name="First" onclick=goto_first(this.form)>&nbsp;')
	newWind.document.write('<input type="button" value=" &lt; " name="Prev" onclick=goto_prev(this.form)>&nbsp;&nbsp;\n');
	newWind.document.write('<select name=url onchange=menu_goto(this.form)> \n');
	for (var i=0; i<cnt ;i++ ) {
		newWind.document.write('<option value="#C'+i+'">Change #'+(i+1)+ '</option> \n');
		}
	newWind.document.write('');
	newWind.document.write('</select>&nbsp;&nbsp;\n');
	newWind.document.write('<input type="button" value=" &gt; " name="Next"\n');
	newWind.document.write('onclick=goto_next(this.form)>\n');
	newWind.document.write('<input type="button" value=" &gt| " name="Last"\n');
	newWind.document.write('onclick=goto_last(this.form)>\n');
	newWind.document.write('</form>\n');
	newWind.document.write('');
	newWind.document.write('<form method="POST">\n');
	newWind.document.write('<p align="center"><i><font size="3">Generated\n');
	newWind.document.write('by <a href="http://www.ComponentSoftware.com/products/htmldiff" target="_blank">HtmlDiff</a> \n');
	newWind.document.write('</form>\n');
	newWind.document.write('</body>\n');
	newWind.document.write('</html>\n');
	newWind.document.write('<SCRIPT LANGUAGE="JavaScript" TYPE="text/javascript">\n');
	newWind.document.write('<!--\n');
	newWind.document.write('');
	newWind.document.write('var directCloseFlag=1;\n');
	newWind.document.write('');
	newWind.document.write('function menu_goto( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('  var baseurl = opener.location.href ;\n');
	newWind.document.write('  var idx = baseurl.indexOf("#");\n');
	newWind.document.write('  if (idx > -1) {\n');
	newWind.document.write('	baseurl = baseurl.slice(0, idx);\n');
	newWind.document.write('  }');
	newWind.document.write('  selecteditem = menuform.url.selectedIndex ;\n');
	newWind.document.write('  newurl = menuform.url.options[ selecteditem ].value ;\n');
	newWind.document.write('  if (newurl.length != 0) {\n');
	newWind.document.write('    	opener.top.location.href = baseurl + newurl ;\n');
	newWind.document.write('  }');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_prev( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	if(menuform.url.selectedIndex>0) menuform.url.selectedIndex--;\n');
	newWind.document.write('	menu_goto( menuform )\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_first( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	menuform.url.selectedIndex = 0;	\n');
	newWind.document.write('	menu_goto( menuform );\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_last( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	menuform.url.selectedIndex = menuform.url.options.length-1;	\n');
	newWind.document.write('	menu_goto( menuform );\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_next( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	if(menuform.url.options.length > (menuform.url.selectedIndex+1))\n');
	newWind.document.write('	menuform.url.selectedIndex++;\n');
	newWind.document.write('	menu_goto( menuform )\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function restore()\n');
	newWind.document.write('{\n');
	newWind.document.write('    	focus();\n');
	newWind.document.write('	menu_goto(jump);\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('goto_first(jump)\n');
	newWind.document.write('//-->\n');
	newWind.document.write('<');
	newWind.document.write('/SCRIPT>\n');
}
function pop_navigate(){
  if ((newWind==null)||(newWind.closed)) {
    newWind =  window.open("" ,"HtmlDiffJumpWindow","width=270,height=40")
    if (newWind.opener == null) { // for Nav 2.0x
      newWind.opener = self // this creates and sets a new prop
    }	putJumpCode();
  
} 
else 
{	newWind.execScript("restore()", "JavaScript");
  }
}
function exit(){
  if (newWind != null) {   
	newWind.close();
  }
}
//--></SCRIPT></html>
