<body onunload=exit()><form method="POST">  <p align="center"><i><font size="3">Difference Analysis Generated by   <a href="http://www.ComponentSoftware.com/products/htmldiff" target="_blank">HtmlDiff</a> on  6/3/2003 11:47 AM</font></i>&nbsp;&nbsp;
  <input type="button" value="Navigate Changes" name="Navigate" onclick=pop_navigate()></p></form></body> <p align="left"><font size="4"><b>Base file: C:\Development\jts1.2\src\com\vividsolutions\jts\geom\IntersectionMatrix.java</b></font></p> <p align="left"><font size="4"><b>Modified file: C:\Development\jts1.3\src\com\vividsolutions\jts\geom\IntersectionMatrix.java</b></font></p><html>
<style type="text/css">
<!--
.HDNormal {  color: #000000;background:  #ffffff;text-decoration:none}
.HDDeleted {  color: #ff0000;background:  #ffffff;text-decoration:line-through}
.HDAdded {  color: #000000;background:  #ffff00;text-decoration:none}
-->
</style>
<body class="HDNormal">
<pre><a name="diff" id="c0"><span class="HDAdded">1:  
2:  
</span></a>1:  /*
2:   * <a name="diff" id="c1"><span class="HDDeleted"> </span></a>The <span class="HDDeleted">Java </span><span class="HDAdded">JTS </span>Topology Suite<span class="HDDeleted"> (JTS)</span> is a collection of Java classes that
3:   *  implement the fundamental operations required to validate a given
4:   *  geo-spatial data set to a known topological specification.
5:   *
6:   *  Copyright (C) 2001 Vivid Solutions
7:   *
8:   *  This library is free software; you can redistribute it and/or
9:   *  modify it under the terms of the GNU Lesser General Public
10:  *  License as published by the Free Software Foundation; either
11:  *  version 2.1 of the License, or (at your option) any later version.
12:  *
13:  *  This library is distributed in the hope that it will be useful,
14:  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
15:  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
16:  *  Lesser General Public License for more details.
17:  *
18:  *  You should have received a copy of the GNU Lesser General Public
19:  *  License along with this library; if not, write to the Free Software
20:  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
21:  *
22:  *  For more information, contact:
23:  *
24:  *  Vivid Solutions
25:  *  Suite #1A
26:  *  2328 Government Street
27:  *  Victoria BC  V8T 5G5
28:  *  Canada
29:  *
30:  *  (250)385-6040
31:  *  www.vividsolutions.com
32:  */
33: package com.vividsolutions.jts.geom;
<a name="diff" id="c2"><span class="HDDeleted">34: import com.vividsolutions.jts.geom.Dimension;
35: import com.vividsolutions.jts.geom.Location;
36: import com.vividsolutions.jts.util.Assert;
37: 
38: import java.lang.IllegalArgumentException;
</span></a>39: 
40: /**
41:  *  A Dimensionally Extended Nine-Intersection Model (DE-9IM) matrix. This class
42:  *  can used to represent both computed DE-9IM's (like 212FF1FF2) as well as
43:  *  patterns for matching them (like T*T******). &lt;P&gt;
44:  *
45:  *  Methods are provided to:
46:  *  &lt;UL&gt;
47:  *    &lt;LI&gt; set and query the elements of the matrix in a convenient fashion
48:  *    &lt;LI&gt; convert to and from the standard string representation (specified in
49:  *    SFS Section 2.1.13.2).
50:  *    &lt;LI&gt; test to see if a matrix matches a given pattern string.
51:  *  &lt;/UL&gt;
52:  *  &lt;P&gt;
53:  *
54:  *  For a description of the DE-9IM, see the &lt;A
55:  *  HREF="http://www.opengis.org/techno/specs.htm"&gt;OpenGIS Simple Features
56:  *  Specification for SQL&lt;/A&gt; .
57:  *
58:  *@version 1.<a name="diff" id="c3"><span class="HDDeleted">2</span></a><span class="HDAdded">3</span>
59:  */
60: public class IntersectionMatrix implements Cloneable {
61:   /**
62:    *  Internal representation of this &lt;code&gt;IntersectionMatrix&lt;/code&gt;.
63:    */
64:   private int[][] matrix;
65: 
66:   /**
67:    *  Creates an &lt;code&gt;IntersectionMatrix&lt;/code&gt; with &lt;code&gt;FALSE&lt;/code&gt;
68:    *  dimension values.
69:    */
70:   public IntersectionMatrix() {
71:     matrix = new int[3][3];
72:     setAll(Dimension.FALSE);
73:   }
74: 
75:   /**
76:    *  Creates an &lt;code&gt;IntersectionMatrix&lt;/code&gt; with the given dimension
77:    *  symbols.
78:    *
79:    *@param  elements  a String of nine dimension symbols in row major order
80:    */
81:   public IntersectionMatrix(String elements) {
82:     this();
83:     set(elements);
84:   }
85: 
86:   /**
87:    *  Creates an &lt;code&gt;IntersectionMatrix&lt;/code&gt; with the same elements as
88:    *  &lt;code&gt;other&lt;/code&gt;.
89:    *
90:    *@param  other  an &lt;code&gt;IntersectionMatrix&lt;/code&gt; to copy
91:    */
92:   public IntersectionMatrix(IntersectionMatrix other) {
93:     this();
94:     matrix[Location.INTERIOR][Location.INTERIOR] = other.matrix[Location.INTERIOR][Location.INTERIOR];
95:     matrix[Location.INTERIOR][Location.BOUNDARY] = other.matrix[Location.INTERIOR][Location.BOUNDARY];
96:     matrix[Location.INTERIOR][Location.EXTERIOR] = other.matrix[Location.INTERIOR][Location.EXTERIOR];
97:     matrix[Location.BOUNDARY][Location.INTERIOR] = other.matrix[Location.BOUNDARY][Location.INTERIOR];
98:     matrix[Location.BOUNDARY][Location.BOUNDARY] = other.matrix[Location.BOUNDARY][Location.BOUNDARY];
99:     matrix[Location.BOUNDARY][Location.EXTERIOR] = other.matrix[Location.BOUNDARY][Location.EXTERIOR];
100:        matrix[Location.EXTERIOR][Location.INTERIOR] = other.matrix[Location.EXTERIOR][Location.INTERIOR];
101:        matrix[Location.EXTERIOR][Location.BOUNDARY] = other.matrix[Location.EXTERIOR][Location.BOUNDARY];
102:        matrix[Location.EXTERIOR][Location.EXTERIOR] = other.matrix[Location.EXTERIOR][Location.EXTERIOR];
<a name="diff" id="c4"><span class="HDAdded">100:      }
101:    
102:      /**
103:       * Adds one matrix to another.
104:       * Addition is defined by taking the maximum dimension value of each position
105:       * in the summand matrices.
106:       *
107:       * @param im the matrix to add
108:       */
109:      public void add(IntersectionMatrix im)
110:      {
111:        for (int i = 0; i &lt; 3; i++) {
112:          for (int j = 0; j &lt; 3; j++) {
113:            setAtLeast(i, j, im.get(i, j));
114:          }
115:        }
</span></a>103:      }
104:    
105:      /**
106:       *  Returns true if the dimension value satisfies the dimension symbol.
107:       *
108:       *@param  actualDimensionValue     a number that can be stored in the &lt;code&gt;IntersectionMatrix&lt;/code&gt;
109:       *      . Possible values are &lt;code&gt;{TRUE, FALSE, DONTCARE, 0, 1, 2}&lt;/code&gt;.
110:       *@param  requiredDimensionSymbol  a character used in the string
111:       *      representation of an &lt;code&gt;IntersectionMatrix&lt;/code&gt;. Possible values
112:       *      are &lt;code&gt;{T, F, * , 0, 1, 2}&lt;/code&gt;.
113:       *@return                          true if the dimension symbol encompasses
114:       *      the dimension value
115:       */
116:      public static boolean matches(int actualDimensionValue, char requiredDimensionSymbol) {
117:        if (requiredDimensionSymbol == '*') {
118:          return true;
119:        }
120:        if (requiredDimensionSymbol == 'T' &amp;&amp; (actualDimensionValue &gt;= 0 || actualDimensionValue
121:             == Dimension.TRUE)) {
122:          return true;
123:        }
124:        if (requiredDimensionSymbol == 'F' &amp;&amp; actualDimensionValue == Dimension.FALSE) {
125:          return true;
126:        }
127:        if (requiredDimensionSymbol == '0' &amp;&amp; actualDimensionValue == Dimension.P) {
128:          return true;
129:        }
130:        if (requiredDimensionSymbol == '1' &amp;&amp; actualDimensionValue == Dimension.L) {
131:          return true;
132:        }
133:        if (requiredDimensionSymbol == '2' &amp;&amp; actualDimensionValue == Dimension.A) {
134:          return true;
135:        }
136:        return false;
137:      }
138:    
139:      /**
140:       *  Returns true if each of the actual dimension symbols satisfies the
141:       *  corresponding required dimension symbol.
142:       *
143:       *@param  actualDimensionSymbols    nine dimension symbols to validate.
144:       *      Possible values are &lt;code&gt;{T, F, * , 0, 1, 2}&lt;/code&gt;.
145:       *@param  requiredDimensionSymbols  nine dimension symbols to validate
146:       *      against. Possible values are &lt;code&gt;{T, F, * , 0, 1, 2}&lt;/code&gt;.
147:       *@return                           true if each of the required dimension
148:       *      symbols encompass the corresponding actual dimension symbol
149:       */
150:      public static boolean matches(String actualDimensionSymbols, String requiredDimensionSymbols) {
151:        IntersectionMatrix m = new IntersectionMatrix(actualDimensionSymbols);
152:        return m.matches(requiredDimensionSymbols);
153:      }
154:    
155:      /**
156:       *  Changes the value of one of this &lt;code&gt;IntersectionMatrix&lt;/code&gt;s
157:       *  elements.
158:       *
159:       *@param  row             the row of this &lt;code&gt;IntersectionMatrix&lt;/code&gt;,
160:       *      indicating the interior, boundary or exterior of the first &lt;code&gt;Geometry&lt;/code&gt;
161:       *@param  column          the column of this &lt;code&gt;IntersectionMatrix&lt;/code&gt;,
162:       *      indicating the interior, boundary or exterior of the second &lt;code&gt;Geometry&lt;/code&gt;
163:       *@param  dimensionValue  the new value of the element
164:       */
165:      public void set(int row, int column, int dimensionValue) {
166:        matrix[row][column] = dimensionValue;
167:      }
168:    
169:      /**
170:       *  Changes the elements of this &lt;code&gt;IntersectionMatrix&lt;/code&gt; to the
171:       *  dimension symbols in &lt;code&gt;dimensionSymbols&lt;/code&gt;.
172:       *
173:       *@param  dimensionSymbols  nine dimension symbols to which to set this &lt;code&gt;IntersectionMatrix&lt;/code&gt;
174:       *      s elements. Possible values are &lt;code&gt;{T, F, * , 0, 1, 2}&lt;/code&gt;
175:       */
176:      public void set(String dimensionSymbols) {
177:        for (int i = 0; i &lt; dimensionSymbols.length(); i++) {
178:          int row = i / 3;
179:          int col = i % 3;
180:          matrix[row][col] = Dimension.toDimensionValue(dimensionSymbols.charAt(i));
181:        }
182:      }
183:    
184:      /**
185:       *  Changes the specified element to &lt;code&gt;minimumDimensionValue&lt;/code&gt; if the
186:       *  element is less.
187:       *
188:       *@param  row                    the row of this &lt;code&gt;IntersectionMatrix&lt;/code&gt;
189:       *      , indicating the interior, boundary or exterior of the first &lt;code&gt;Geometry&lt;/code&gt;
190:       *@param  column                 the column of this &lt;code&gt;IntersectionMatrix&lt;/code&gt;
191:       *      , indicating the interior, boundary or exterior of the second &lt;code&gt;Geometry&lt;/code&gt;
192:       *@param  minimumDimensionValue  the dimension value with which to compare the
193:       *      element. The order of dimension values from least to greatest is
194:       *      &lt;code&gt;{DONTCARE, TRUE, FALSE, 0, 1, 2}&lt;/code&gt;.
195:       */
196:      public void setAtLeast(int row, int column, int minimumDimensionValue) {
197:        if (matrix[row][column] &lt; minimumDimensionValue) {
198:          matrix[row][column] = minimumDimensionValue;
199:        }
200:      }
201:    
202:      /**
203:       *  If row &gt;= 0 and column &gt;= 0, changes the specified element to &lt;code&gt;minimumDimensionValue&lt;/code&gt;
204:       *  if the element is less. Does nothing if row &lt;0 or column &lt; 0.
205:       *
206:       *@param  row                    the row of this &lt;code&gt;IntersectionMatrix&lt;/code&gt;
207:       *      , indicating the interior, boundary or exterior of the first &lt;code&gt;Geometry&lt;/code&gt;
208:       *@param  column                 the column of this &lt;code&gt;IntersectionMatrix&lt;/code&gt;
209:       *      , indicating the interior, boundary or exterior of the second &lt;code&gt;Geometry&lt;/code&gt;
210:       *@param  minimumDimensionValue  the dimension value with which to compare the
211:       *      element. The order of dimension values from least to greatest is
212:       *      &lt;code&gt;{DONTCARE, TRUE, FALSE, 0, 1, 2}&lt;/code&gt;.
213:       */
214:      public void setAtLeastIfValid(int row, int column, int minimumDimensionValue) {
215:        if (row &gt;= 0 &amp;&amp; column &gt;= 0) {
216:          setAtLeast(row, column, minimumDimensionValue);
217:        }
218:      }
219:    
220:      /**
221:       *  For each element in this &lt;code&gt;IntersectionMatrix&lt;/code&gt;, changes the
222:       *  element to the corresponding minimum dimension symbol if the element is
223:       *  less.
224:       *
225:       *@param  minimumDimensionSymbols  nine dimension symbols with which to
226:       *      compare the elements of this &lt;code&gt;IntersectionMatrix&lt;/code&gt;. The
227:       *      order of dimension values from least to greatest is &lt;code&gt;{DONTCARE, TRUE, FALSE, 0, 1, 2}&lt;/code&gt;
228:       *      .
229:       */
230:      public void setAtLeast(String minimumDimensionSymbols) {
231:        for (int i = 0; i &lt; minimumDimensionSymbols.length(); i++) {
232:          int row = i / 3;
233:          int col = i % 3;
234:          setAtLeast(row, col, Dimension.toDimensionValue(minimumDimensionSymbols.charAt(i)));
235:        }
236:      }
237:    
238:      /**
239:       *  Changes the elements of this &lt;code&gt;IntersectionMatrix&lt;/code&gt; to &lt;code&gt;dimensionValue&lt;/code&gt;
240:       *  .
241:       *
242:       *@param  dimensionValue  the dimension value to which to set this &lt;code&gt;IntersectionMatrix&lt;/code&gt;
243:       *      s elements. Possible values &lt;code&gt;{TRUE, FALSE, DONTCARE, 0, 1, 2}&lt;/code&gt;
244:       *      .
245:       */
246:      public void setAll(int dimensionValue) {
247:        for (int ai = 0; ai &lt; 3; ai++) {
248:          for (int bi = 0; bi &lt; 3; bi++) {
249:            matrix[ai][bi] = dimensionValue;
250:          }
251:        }
252:      }
253:    
254:      /**
255:       *  Returns the value of one of this &lt;code&gt;IntersectionMatrix&lt;/code&gt;s
256:       *  elements.
257:       *
258:       *@param  row     the row of this &lt;code&gt;IntersectionMatrix&lt;/code&gt;, indicating
259:       *      the interior, boundary or exterior of the first &lt;code&gt;Geometry&lt;/code&gt;
260:       *@param  column  the column of this &lt;code&gt;IntersectionMatrix&lt;/code&gt;,
261:       *      indicating the interior, boundary or exterior of the second &lt;code&gt;Geometry&lt;/code&gt;
262:       *@return         the dimension value at the given matrix position.
263:       */
264:      public int get(int row, int column) {
265:        return matrix[row][column];
266:      }
267:    
268:      /**
269:       *  Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;IntersectionMatrix&lt;/code&gt; is
270:       *  FF*FF****.
271:       *
272:       *@return    &lt;code&gt;true&lt;/code&gt; if the two &lt;code&gt;Geometry&lt;/code&gt;s related by
273:       *      this &lt;code&gt;IntersectionMatrix&lt;/code&gt; are disjoint
274:       */
275:      public boolean isDisjoint() {
276:        return
277:            matrix[Location.INTERIOR][Location.INTERIOR] == Dimension.FALSE &amp;&amp;
278:            matrix[Location.INTERIOR][Location.BOUNDARY] == Dimension.FALSE &amp;&amp;
279:            matrix[Location.BOUNDARY][Location.INTERIOR] == Dimension.FALSE &amp;&amp;
280:            matrix[Location.BOUNDARY][Location.BOUNDARY] == Dimension.FALSE;
281:      }
282:    
283:      /**
284:       *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;isDisjoint&lt;/code&gt; returns false.
285:       *
286:       *@return    &lt;code&gt;true&lt;/code&gt; if the two &lt;code&gt;Geometry&lt;/code&gt;s related by
287:       *      this &lt;code&gt;IntersectionMatrix&lt;/code&gt; intersect
288:       */
289:      public boolean isIntersects() {
290:        return !isDisjoint();
291:      }
292:    
293:      /**
294:       *  Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;IntersectionMatrix&lt;/code&gt; is
295:       *  FT*******, F**T***** or F***T****.
296:       *
297:       *@param  dimensionOfGeometryA  the dimension of the first &lt;code&gt;Geometry&lt;/code&gt;
298:       *@param  dimensionOfGeometryB  the dimension of the second &lt;code&gt;Geometry&lt;/code&gt;
299:       *@return                       &lt;code&gt;true&lt;/code&gt; if the two &lt;code&gt;Geometry&lt;/code&gt;
300:       *      s related by this &lt;code&gt;IntersectionMatrix&lt;/code&gt; touch; Returns false
301:       *      if both &lt;code&gt;Geometry&lt;/code&gt;s are points.
302:       */
303:      public boolean isTouches(int dimensionOfGeometryA, int dimensionOfGeometryB) {
304:        if (dimensionOfGeometryA &gt; dimensionOfGeometryB) {
305:          //no need to get transpose because pattern matrix is symmetrical
306:          return isTouches(dimensionOfGeometryB, dimensionOfGeometryA);
307:        }
308:        if ((dimensionOfGeometryA == Dimension.A &amp;&amp; dimensionOfGeometryB == Dimension.A) ||
309:            (dimensionOfGeometryA == Dimension.L &amp;&amp; dimensionOfGeometryB == Dimension.L) ||
310:            (dimensionOfGeometryA == Dimension.L &amp;&amp; dimensionOfGeometryB == Dimension.A) ||
311:            (dimensionOfGeometryA == Dimension.P &amp;&amp; dimensionOfGeometryB == Dimension.A) ||
312:            (dimensionOfGeometryA == Dimension.P &amp;&amp; dimensionOfGeometryB == Dimension.L)) {
313:          return matrix[Location.INTERIOR][Location.INTERIOR] == Dimension.FALSE &amp;&amp;
314:              (matches(matrix[Location.INTERIOR][Location.BOUNDARY], 'T')
315:               || matches(matrix[Location.BOUNDARY][Location.INTERIOR], 'T')
316:               || matches(matrix[Location.BOUNDARY][Location.BOUNDARY], 'T'));
317:        }
318:        return false;
319:      }
320:    
321:      /**
322:       *  Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;IntersectionMatrix&lt;/code&gt; is
323:       *  &lt;UL&gt;
324:       *    &lt;LI&gt; T*T****** (for a point and a curve, a point and an area or a line
325:       *    and an area)
326:       *    &lt;LI&gt; 0******** (for two curves)
327:       *  &lt;/UL&gt;
328:       *  .
329:       *
330:       *@param  dimensionOfGeometryA  the dimension of the first &lt;code&gt;Geometry&lt;/code&gt;
331:       *@param  dimensionOfGeometryB  the dimension of the second &lt;code&gt;Geometry&lt;/code&gt;
332:       *@return                       &lt;code&gt;true&lt;/code&gt; if the two &lt;code&gt;Geometry&lt;/code&gt;
333:       *      s related by this &lt;code&gt;IntersectionMatrix&lt;/code&gt; cross. For this
334:       *      function to return &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;Geometry&lt;/code&gt;s must
335:       *      be a point and a curve; a point and a surface; two curves; or a curve
336:       *      and a surface.
337:       */
338:      public boolean isCrosses(int dimensionOfGeometryA, int dimensionOfGeometryB) {
339:        if ((dimensionOfGeometryA == Dimension.P &amp;&amp; dimensionOfGeometryB == Dimension.L) ||
340:            (dimensionOfGeometryA == Dimension.P &amp;&amp; dimensionOfGeometryB == Dimension.A) ||
341:            (dimensionOfGeometryA == Dimension.L &amp;&amp; dimensionOfGeometryB == Dimension.A)) {
342:          return matches(matrix[Location.INTERIOR][Location.INTERIOR], 'T') &amp;&amp;
343:              matches(matrix[Location.INTERIOR][Location.EXTERIOR], 'T');
344:        }
345:        if ((dimensionOfGeometryA == Dimension.L &amp;&amp; dimensionOfGeometryB == Dimension.P) ||
346:            (dimensionOfGeometryA == Dimension.A &amp;&amp; dimensionOfGeometryB == Dimension.P) ||
347:            (dimensionOfGeometryA == Dimension.A &amp;&amp; dimensionOfGeometryB == Dimension.L)) {
348:          return matches(matrix[Location.INTERIOR][Location.INTERIOR], 'T') &amp;&amp;
349:              matches(matrix[Location.EXTERIOR][Location.INTERIOR], 'T');
350:        }
351:        if (dimensionOfGeometryA == Dimension.L &amp;&amp; dimensionOfGeometryB == Dimension.L) {
352:          return matrix[Location.INTERIOR][Location.INTERIOR] == 0;
353:        }
354:        return false;
355:      }
356:    
357:      /**
358:       *  Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;IntersectionMatrix&lt;/code&gt; is
359:       *  T*F**F***.
360:       *
361:       *@return    &lt;code&gt;true&lt;/code&gt; if the first &lt;code&gt;Geometry&lt;/code&gt; is within
362:       *      the second
363:       */
364:      public boolean isWithin() {
365:        return matches(matrix[Location.INTERIOR][Location.INTERIOR], 'T') &amp;&amp;
366:            matrix[Location.INTERIOR][Location.EXTERIOR] == Dimension.FALSE &amp;&amp;
367:            matrix[Location.BOUNDARY][Location.EXTERIOR] == Dimension.FALSE;
368:      }
369:    
370:      /**
371:       *  Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;IntersectionMatrix&lt;/code&gt; is
372:       *  T*****FF*.
373:       *
374:       *@return    &lt;code&gt;true&lt;/code&gt; if the first &lt;code&gt;Geometry&lt;/code&gt; contains the
375:       *      second
376:       */
377:      public boolean isContains() {
378:        return matches(matrix[Location.INTERIOR][Location.INTERIOR], 'T') &amp;&amp;
379:            matrix[Location.EXTERIOR][Location.INTERIOR] == Dimension.FALSE &amp;&amp;
380:            matrix[Location.EXTERIOR][Location.BOUNDARY] == Dimension.FALSE;
381:      }
382:    
383:      /**
384:       *  Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;IntersectionMatrix&lt;/code&gt; is
385:       *  T*F**FFF*.
386:       *
387:       *@param  dimensionOfGeometryA  the dimension of the first &lt;code&gt;Geometry&lt;/code&gt;
388:       *@param  dimensionOfGeometryB  the dimension of the second &lt;code&gt;Geometry&lt;/code&gt;
389:       *@return                       &lt;code&gt;true&lt;/code&gt; if the two &lt;code&gt;Geometry&lt;/code&gt;
390:       *      s related by this &lt;code&gt;IntersectionMatrix&lt;/code&gt; are equal; the
391:       *      &lt;code&gt;Geometry&lt;/code&gt;s must have the same dimension for this function
392:       *      to return &lt;code&gt;true&lt;/code&gt;
393:       */
394:      public boolean isEquals(int dimensionOfGeometryA, int dimensionOfGeometryB) {
395:        if (dimensionOfGeometryA != dimensionOfGeometryB) {
396:          return false;
397:        }
398:        return matches(matrix[Location.INTERIOR][Location.INTERIOR], 'T') &amp;&amp;
399:            matrix[Location.EXTERIOR][Location.INTERIOR] == Dimension.FALSE &amp;&amp;
400:            matrix[Location.INTERIOR][Location.EXTERIOR] == Dimension.FALSE &amp;&amp;
401:            matrix[Location.EXTERIOR][Location.BOUNDARY] == Dimension.FALSE &amp;&amp;
402:            matrix[Location.BOUNDARY][Location.EXTERIOR] == Dimension.FALSE;
403:      }
404:    
405:      /**
406:       *  Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;IntersectionMatrix&lt;/code&gt; is
407:       *  &lt;UL&gt;
408:       *    &lt;LI&gt; T*T***T** (for two points or two surfaces)
409:       *    &lt;LI&gt; 1*T***T** (for two curves)
410:       *  &lt;/UL&gt;
411:       *  .
412:       *
413:       *@param  dimensionOfGeometryA  the dimension of the first &lt;code&gt;Geometry&lt;/code&gt;
414:       *@param  dimensionOfGeometryB  the dimension of the second &lt;code&gt;Geometry&lt;/code&gt;
415:       *@return                       &lt;code&gt;true&lt;/code&gt; if the two &lt;code&gt;Geometry&lt;/code&gt;
416:       *      s related by this &lt;code&gt;IntersectionMatrix&lt;/code&gt; overlap. For this
417:       *      function to return &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;Geometry&lt;/code&gt;s must
418:       *      be two points, two curves or two surfaces.
419:       */
420:      public boolean isOverlaps(int dimensionOfGeometryA, int dimensionOfGeometryB) {
421:        if ((dimensionOfGeometryA == Dimension.P &amp;&amp; dimensionOfGeometryB == Dimension.P) ||
422:            (dimensionOfGeometryA == Dimension.A &amp;&amp; dimensionOfGeometryB == Dimension.A)) {
423:          return matches(matrix[Location.INTERIOR][Location.INTERIOR], 'T') &amp;&amp;
424:              matches(matrix[Location.INTERIOR][Location.EXTERIOR], 'T') &amp;&amp; matches(matrix[Location.EXTERIOR][Location.INTERIOR],
425:              'T');
426:        }
427:        if (dimensionOfGeometryA == Dimension.L &amp;&amp; dimensionOfGeometryB == Dimension.L) {
428:          return matrix[Location.INTERIOR][Location.INTERIOR] == 1 &amp;&amp;
429:              matches(matrix[Location.INTERIOR][Location.EXTERIOR], 'T') &amp;&amp;
430:              matches(matrix[Location.EXTERIOR][Location.INTERIOR], 'T');
431:        }
432:        return false;
433:      }
434:    
435:      /**
436:       *  Returns whether the elements of this &lt;code&gt;IntersectionMatrix&lt;/code&gt;
437:       *  satisfies the required dimension symbols.
438:       *
439:       *@param  requiredDimensionSymbols  nine dimension symbols with which to
440:       *      compare the elements of this &lt;code&gt;IntersectionMatrix&lt;/code&gt;. Possible
441:       *      values are &lt;code&gt;{T, F, * , 0, 1, 2}&lt;/code&gt;.
442:       *@return                           &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;IntersectionMatrix&lt;/code&gt;
443:       *      matches the required dimension symbols
444:       */
445:      public boolean matches(String requiredDimensionSymbols) {
446:        if (requiredDimensionSymbols.length() != 9) {
447:          throw new IllegalArgumentException("Should be length 9: " + requiredDimensionSymbols);
448:        }
449:        for (int ai = 0; ai &lt; 3; ai++) {
450:          for (int bi = 0; bi &lt; 3; bi++) {
451:            if (!matches(matrix[ai][bi], requiredDimensionSymbols.charAt(3 * ai +
452:                bi))) {
453:              return false;
454:            }
455:          }
456:        }
457:        return true;
458:      }
459:    
460:      /**
461:       *  Transposes this IntersectionMatrix.
462:       *
463:       *@return    this &lt;code&gt;IntersectionMatrix&lt;/code&gt; as a convenience
464:       */
465:      public IntersectionMatrix transpose() {
466:        int temp = matrix[1][0];
467:        matrix[1][0] = matrix[0][1];
468:        matrix[0][1] = temp;
469:        temp = matrix[2][0];
470:        matrix[2][0] = matrix[0][2];
471:        matrix[0][2] = temp;
472:        temp = matrix[2][1];
473:        matrix[2][1] = matrix[1][2];
474:        matrix[1][2] = temp;
475:        return this;
476:      }
477:    
478:      /**
479:       *  Returns a nine-character &lt;code&gt;String&lt;/code&gt; representation of this &lt;code&gt;IntersectionMatrix&lt;/code&gt;
480:       *  .
481:       *
482:       *@return    the nine dimension symbols of this &lt;code&gt;IntersectionMatrix&lt;/code&gt;
483:       *      in row-major order.
484:       */
485:      public String toString() {
486:        StringBuffer buf = new StringBuffer("123456789");
487:        for (int ai = 0; ai &lt; 3; ai++) {
488:          for (int bi = 0; bi &lt; 3; bi++) {
489:            buf.setCharAt(3 * ai + bi, Dimension.toDimensionSymbol(matrix[ai][bi]));
490:          }
491:        }
492:        return buf.toString();
493:      }
494:    }
495:    
</pre>
</body>
<SCRIPT LANGUAGE="JavaScript" TYPE="text/javascript">
<!--
var newWind;
function putJumpCode(){
	var cnt = 5;
	newWind.document.write('<html>\n');
	newWind.document.write('<title>HtmlDiff Navigation</title>\n');
	newWind.document.write('<body>\n');
	newWind.document.write('<form name="jump">\n');
	newWind.document.write('<input type="button" value=" |&lt; " name="First" onclick=goto_first(this.form)>&nbsp;')
	newWind.document.write('<input type="button" value=" &lt; " name="Prev" onclick=goto_prev(this.form)>&nbsp;&nbsp;\n');
	newWind.document.write('<select name=url onchange=menu_goto(this.form)> \n');
	for (var i=0; i<cnt ;i++ ) {
		newWind.document.write('<option value="#C'+i+'">Change #'+(i+1)+ '</option> \n');
		}
	newWind.document.write('');
	newWind.document.write('</select>&nbsp;&nbsp;\n');
	newWind.document.write('<input type="button" value=" &gt; " name="Next"\n');
	newWind.document.write('onclick=goto_next(this.form)>\n');
	newWind.document.write('<input type="button" value=" &gt| " name="Last"\n');
	newWind.document.write('onclick=goto_last(this.form)>\n');
	newWind.document.write('</form>\n');
	newWind.document.write('');
	newWind.document.write('<form method="POST">\n');
	newWind.document.write('<p align="center"><i><font size="3">Generated\n');
	newWind.document.write('by <a href="http://www.ComponentSoftware.com/products/htmldiff" target="_blank">HtmlDiff</a> \n');
	newWind.document.write('</form>\n');
	newWind.document.write('</body>\n');
	newWind.document.write('</html>\n');
	newWind.document.write('<SCRIPT LANGUAGE="JavaScript" TYPE="text/javascript">\n');
	newWind.document.write('<!--\n');
	newWind.document.write('');
	newWind.document.write('var directCloseFlag=1;\n');
	newWind.document.write('');
	newWind.document.write('function menu_goto( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('  var baseurl = opener.location.href ;\n');
	newWind.document.write('  var idx = baseurl.indexOf("#");\n');
	newWind.document.write('  if (idx > -1) {\n');
	newWind.document.write('	baseurl = baseurl.slice(0, idx);\n');
	newWind.document.write('  }');
	newWind.document.write('  selecteditem = menuform.url.selectedIndex ;\n');
	newWind.document.write('  newurl = menuform.url.options[ selecteditem ].value ;\n');
	newWind.document.write('  if (newurl.length != 0) {\n');
	newWind.document.write('    	opener.top.location.href = baseurl + newurl ;\n');
	newWind.document.write('  }');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_prev( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	if(menuform.url.selectedIndex>0) menuform.url.selectedIndex--;\n');
	newWind.document.write('	menu_goto( menuform )\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_first( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	menuform.url.selectedIndex = 0;	\n');
	newWind.document.write('	menu_goto( menuform );\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_last( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	menuform.url.selectedIndex = menuform.url.options.length-1;	\n');
	newWind.document.write('	menu_goto( menuform );\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_next( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	if(menuform.url.options.length > (menuform.url.selectedIndex+1))\n');
	newWind.document.write('	menuform.url.selectedIndex++;\n');
	newWind.document.write('	menu_goto( menuform )\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function restore()\n');
	newWind.document.write('{\n');
	newWind.document.write('    	focus();\n');
	newWind.document.write('	menu_goto(jump);\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('goto_first(jump)\n');
	newWind.document.write('//-->\n');
	newWind.document.write('<');
	newWind.document.write('/SCRIPT>\n');
}
function pop_navigate(){
  if ((newWind==null)||(newWind.closed)) {
    newWind =  window.open("" ,"HtmlDiffJumpWindow","width=270,height=40")
    if (newWind.opener == null) { // for Nav 2.0x
      newWind.opener = self // this creates and sets a new prop
    }	putJumpCode();
  
} 
else 
{	newWind.execScript("restore()", "JavaScript");
  }
}
function exit(){
  if (newWind != null) {   
	newWind.close();
  }
}
//--></SCRIPT></html>
