<body onunload=exit()><form method="POST">  <p align="center"><i><font size="3">Difference Analysis Generated by   <a href="http://www.ComponentSoftware.com/products/htmldiff" target="_blank">HtmlDiff</a> on  6/3/2003 11:47 AM</font></i>&nbsp;&nbsp;
  <input type="button" value="Navigate Changes" name="Navigate" onclick=pop_navigate()></p></form></body> <p align="left"><font size="4"><b>Base file: C:\Development\jts1.2\src\com\vividsolutions\jts\geom\sfs\SFSGeometry.java</b></font></p> <p align="left"><font size="4"><b>Modified file: C:\Development\jts1.3\src\com\vividsolutions\jts\geom\sfs\SFSGeometry.java</b></font></p><html>
<style type="text/css">
<!--
.HDNormal {  color: #000000;background:  #ffffff;text-decoration:none}
.HDDeleted {  color: #ff0000;background:  #ffffff;text-decoration:line-through}
.HDAdded {  color: #000000;background:  #ffff00;text-decoration:none}
-->
</style>
<body class="HDNormal">
<pre><a name="diff" id="c0"><span class="HDAdded">1:  
2:  
</span></a>1:  /*
2:   * <a name="diff" id="c1"><span class="HDDeleted"> </span></a>The <span class="HDDeleted">Java </span><span class="HDAdded">JTS </span>Topology Suite<span class="HDDeleted"> (JTS)</span> is a collection of Java classes that
3:   *  implement the fundamental operations required to validate a given
4:   *  geo-spatial data set to a known topological specification.
5:   *
6:   *  Copyright (C) 2001 Vivid Solutions
7:   *
8:   *  This library is free software; you can redistribute it and/or
9:   *  modify it under the terms of the GNU Lesser General Public
10:  *  License as published by the Free Software Foundation; either
11:  *  version 2.1 of the License, or (at your option) any later version.
12:  *
13:  *  This library is distributed in the hope that it will be useful,
14:  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
15:  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
16:  *  Lesser General Public License for more details.
17:  *
18:  *  You should have received a copy of the GNU Lesser General Public
19:  *  License along with this library; if not, write to the Free Software
20:  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
21:  *
22:  *  For more information, contact:
23:  *
24:  *  Vivid Solutions
25:  *  Suite #1A
26:  *  2328 Government Street
27:  *  Victoria BC  V8T 5G5
28:  *  Canada
29:  *
30:  *  (250)385-6040
31:  *  www.vividsolutions.com
32:  */
33: package com.vividsolutions.jts.geom.sfs;
34: 
35: import com.vividsolutions.jts.geom.<a name="diff" id="c2"><span class="HDDeleted">*</span></a><span class="HDAdded">Envelope</span>;
<span class="HDAdded">36: </span><span class="HDAdded">import com.vividsolutions.jts.geom.Geometry;
</span><span class="HDAdded">37: </span><span class="HDAdded">import com.vividsolutions.jts.geom.IntersectionMatrix;
</span><span class="HDAdded">38: </span><span class="HDAdded">import com.vividsolutions.jts.geom.PrecisionModel;
</span>39: 
40: /**
41:  *  A set of points. The spatial relationship predicates (like &lt;code&gt;disjoint&lt;/code&gt;
42:  *  ) are based on the Dimensionally Extended Nine-Intersection Model (DE-9IM).
43:  *  For a description of the DE-9IM, see the &lt;A
44:  *  HREF="http://www.opengis.org/techno/specs.htm"&gt;OpenGIS Simple Features
45:  *  Specification for SQL&lt;/A&gt; . &lt;P&gt;
46:  *
47:  *  A Precision Model object is a member of every Geometry object. &lt;P&gt;
48:  *
49:  *  The SFS specifies that objects of each Geometry subclass may be empty. It is
50:  *  sometimes necessary to construct a generic empty object of class Geometry
51:  *  (e.g. if the exact type of the Geometry to be returned is not known). The
52:  *  SFS does not define a specific class or object to represent a generic
53:  *  empty Geometry. JTS uses the convention that an empty GeometryCollection
54:  *  will be returned.
55:  *
56:  *  &lt;H3&gt; Binary Predicates &lt;/H3&gt;
57:  *  The binary predicates can be
58:  *  completely specified in terms of an &lt;code&gt;IntersectionMatrix&lt;/code&gt; pattern.
59:  *  In fact, their implementation is simply a call to &lt;code&gt;relate&lt;/code&gt; with
60:  *  the appropriate pattern. &lt;P&gt;
61:  *
62:  *  It is important to note that binary predicates are topological operations
63:  *  rather than pointwise operations. Even for apparently straightforward
64:  *  predicates such as &lt;code&gt;equals&lt;/code&gt; it is easy to find cases where a
65:  *  pointwise comparison does not produce the same result as a topological
66:  *  comparison. (for instance: &lt;I&gt;A&lt;/I&gt; and &lt;I&gt;B&lt;/I&gt; are &lt;code&gt;MultiPoint&lt;/code&gt;
67:  *  s with the same point repeated different numbers of times; &lt;I&gt;A&lt;/I&gt; is a
68:  *  &lt;code&gt;LineString&lt;/code&gt; with two collinear line segments and &lt;I&gt;B&lt;/I&gt; is a
69:  *  single line segment with the same start and endpoints). The algorithm used
70:  *  for the &lt;code&gt;relate&lt;/code&gt; method is a topology-based algorithm which
71:  *  produces a topologically correct result. &lt;P&gt;
72:  *
73:  *  As in the SFS, the term &lt;I&gt;P&lt;/I&gt; is used to refer to 0-dimensional &lt;code&gt;Geometry&lt;/code&gt;
74:  *  s (&lt;code&gt;Point&lt;/code&gt; and &lt;code&gt;MultiPoint&lt;/code&gt;), &lt;I&gt;L&lt;/I&gt; to
75:  *  1-dimensional &lt;code&gt;Geometry&lt;/code&gt;s ( &lt;code&gt;LineString&lt;/code&gt;, and &lt;code&gt;MultiLineString&lt;/code&gt;
76:  *  ), and &lt;I&gt;A&lt;/I&gt; to 2-dimensional &lt;code&gt;Geometry&lt;/code&gt;s (&lt;code&gt;Polygon&lt;/code&gt;
77:  *  and &lt;code&gt;MultiPolygon&lt;/code&gt;). The dimension of a &lt;code&gt;GeometryCollection&lt;/code&gt;
78:  *  is equal to the maximum dimension of its components. &lt;P&gt;
79:  *
80:  *  In the SFS some binary predicates are stated to be undefined for some
81:  *  combinations of dimensions (e.g. touches is undefined for &lt;I&gt;P&lt;/I&gt; /&lt;I&gt;P&lt;/I&gt;
82:  *  ). In the interests of simplifying the API, combinations of argument &lt;code&gt;Geometry&lt;/code&gt;
83:  *  s which are not in the domain of a predicate will return &lt;code&gt;false&lt;/code&gt;
84:  *  (e.g. &lt;code&gt;touches(Point, Point) =&gt; false&lt;/code&gt;). &lt;P&gt;
85:  *
86:  *  If either argument to a predicate is an empty &lt;code&gt;Geometry&lt;/code&gt; the
87:  *  predicate will return &lt;code&gt;false&lt;/code&gt;. &lt;H3&gt;Set-Theoretic Methods&lt;/H3&gt; For
88:  *  certain inputs, the &lt;code&gt;difference&lt;/code&gt; and &lt;code&gt;symDifference&lt;/code&gt;
89:  *  methods may compute non-closed sets. This can happen when the arguments
90:  *  overlap and have different dimensions. Since JTS &lt;code&gt;Geometry&lt;/code&gt;
91:  *  objects can represent only closed sets, the spatial analysis methods are
92:  *  specified to return the closure of the point-set-theoretic result.
93:  *
94:  *@version 1.<a name="diff" id="c3"><span class="HDDeleted">2</span></a><span class="HDAdded">3</span>
95:  */
96: public interface SFSGeometry {
97: 
98:   /**
99:    *  Returns the ID of the Spatial Reference System used by the &lt;code&gt;Geometry&lt;/code&gt;
100:       *  . &lt;P&gt;
101:       *
102:       *  JTS supports Spatial Reference System information in the simple way
103:       *  defined in the SFS. A Spatial Reference System ID (SRID) is present in
104:       *  each &lt;code&gt;Geometry&lt;/code&gt; object. &lt;code&gt;Geometry&lt;/code&gt; provides basic
105:       *  accessor operations for this field, but no others. The SRID is represented
106:       *  as an integer.
107:       *
108:       *@return    the ID of the coordinate space in which the &lt;code&gt;Geometry&lt;/code&gt;
109:       *      is defined.
110:       */
111:      int getSRID();
112:    
113:      /**
114:       *  Returns the name of this object's &lt;code&gt;com.vivid.jts.geom&lt;/code&gt;
115:       *  interface.
116:       *
117:       *@return    the name of this &lt;code&gt;Geometry&lt;/code&gt;s most specific &lt;code&gt;com.vividsolutions.jts.geom&lt;/code&gt;
118:       *      interface
119:       */
120:      String getGeometryType();
121:    
122:      /**
123:       *  Returns the &lt;code&gt;PrecisionModel&lt;/code&gt; used by the &lt;code&gt;Geometry&lt;/code&gt;.
124:       *
125:       *@return    the specification of the grid of allowable points, for this
126:       *      &lt;code&gt;Geometry&lt;/code&gt; and all other &lt;code&gt;Geometry&lt;/code&gt;s
127:       */
128:      PrecisionModel getPrecisionModel();
129:    
130:      /**
131:       *  Returns the minimum and maximum x and y values in this &lt;code&gt;Geometry&lt;/code&gt;
132:       *  , or a null &lt;code&gt;Envelope&lt;/code&gt; if this &lt;code&gt;Geometry&lt;/code&gt; is empty.
133:       *
134:       *@return    this &lt;code&gt;Geometry&lt;/code&gt;s bounding box; if the &lt;code&gt;Geometry&lt;/code&gt;
135:       *      is empty, &lt;code&gt;Envelope#isNull&lt;/code&gt; will return &lt;code&gt;true&lt;/code&gt;
136:       */
137:      Envelope getEnvelopeInternal();
138:    
139:      /**
140:       *  Returns this &lt;code&gt;Geometry&lt;/code&gt;s bounding box. If this &lt;code&gt;Geometry&lt;/code&gt;
141:       *  is the empty geometry, returns an empty &lt;code&gt;Point&lt;/code&gt;. If the &lt;code&gt;Geometry&lt;/code&gt;
142:       *  is a point, returns a non-empty &lt;code&gt;Point&lt;/code&gt;. Otherwise, returns a
143:       *  &lt;code&gt;Polygon&lt;/code&gt; whose points are (minx, miny), (maxx, miny), (maxx,
144:       *  maxy), (minx, maxy), (minx, miny).
145:       *
146:       *@return    an empty &lt;code&gt;Point&lt;/code&gt; (for empty &lt;code&gt;Geometry&lt;/code&gt;s), a
147:       *      &lt;code&gt;Point&lt;/code&gt; (for &lt;code&gt;Point&lt;/code&gt;s) or a &lt;code&gt;Polygon&lt;/code&gt;
148:       *      (in all other cases)
149:       */
150:      Geometry getEnvelope();
151:    
152:      /**
153:       *  Returns whether or not the set of points in this &lt;code&gt;Geometry&lt;/code&gt; is
154:       *  empty.
155:       *
156:       *@return    &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Geometry&lt;/code&gt; equals the empty
157:       *      geometry
158:       */
159:      boolean isEmpty();
160:    
161:      /**
162:       *  Returns false if the &lt;code&gt;Geometry&lt;/code&gt; has any anomalous points.
163:       *  Subinterfaces can refine this definition of "simple" in their comments. If
164:       *  this &lt;code&gt;Geometry&lt;/code&gt; is empty, returns &lt;code&gt;true&lt;/code&gt;. &lt;P&gt;
165:       *
166:       *  In general, the SFS specifications of simplicity seem to follow the
167:       *  following rule:
168:       *  &lt;UL&gt;
169:       *    &lt;LI&gt; A Geometry is simple iff the only self-intersections are at
170:       *    boundary points.
171:       *  &lt;/UL&gt;
172:       *  For all empty &lt;code&gt;Geometry&lt;/code&gt;s, &lt;code&gt;isSimple&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt;
173:       *  .
174:       *
175:       *@return    &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Geometry&lt;/code&gt; has any points of
176:       *      self-tangency, self-intersection or other anomalous points
177:       */
178:      boolean isSimple();
179:    
180:      /**
181:       *  Returns the boundary, or the empty geometry if this &lt;code&gt;Geometry&lt;/code&gt;
182:       *  is empty. For a discussion of this function, see the OpenGIS Simple
183:       *  Features Specification. As stated in SFS Section 2.1.13.1, "the boundary
184:       *  of a Geometry is a set of Geometries of the next lower dimension."
185:       *
186:       *@return    the closure of the combinatorial boundary of this &lt;code&gt;Geometry&lt;/code&gt;
187:       *      .
188:       */
189:      Geometry getBoundary();
190:    
191:      /**
192:       *  Returns the inherent dimension of this &lt;code&gt;Geometry&lt;/code&gt;.
193:       *
194:       *@return    the dimension of the class implementing this interface, whether
195:       *      or not this object is the empty geometry
196:       */
197:      int getDimension();
198:    
199:      /**
200:       *  Returns &lt;code&gt;true&lt;/code&gt; if the DE-9IM intersection matrix for the two
201:       *  &lt;code&gt;Geometry&lt;/code&gt;s is T*F**FFF*.
202:       *
203:       *@param  other  the &lt;code&gt;Geometry&lt;/code&gt; with which to compare this &lt;code&gt;Geometry&lt;/code&gt;
204:       *@return        &lt;code&gt;true&lt;/code&gt; if the two &lt;code&gt;Geometry&lt;/code&gt;s are equal
205:       */
206:      boolean equals(Geometry other);
207:    
208:      /**
209:       *  Returns &lt;code&gt;true&lt;/code&gt; if the DE-9IM intersection matrix for the two
210:       *  &lt;code&gt;Geometry&lt;/code&gt;s is FF*FF****.
211:       *
212:       *@param  other  the &lt;code&gt;Geometry&lt;/code&gt; with which to compare this &lt;code&gt;Geometry&lt;/code&gt;
213:       *@return        &lt;code&gt;true&lt;/code&gt; if the two &lt;code&gt;Geometry&lt;/code&gt;s are
214:       *      disjoint
215:       */
216:      boolean disjoint(Geometry other);
217:    
218:      /**
219:       *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;disjoint&lt;/code&gt; returns false.
220:       *
221:       *@param  other  the &lt;code&gt;Geometry&lt;/code&gt; with which to compare this &lt;code&gt;Geometry&lt;/code&gt;
222:       *@return        &lt;code&gt;true&lt;/code&gt; if the two &lt;code&gt;Geometry&lt;/code&gt;s intersect
223:       */
224:      boolean intersects(Geometry other);
225:    
226:      /**
227:       *  Returns &lt;code&gt;true&lt;/code&gt; if the DE-9IM intersection matrix for the two
228:       *  &lt;code&gt;Geometry&lt;/code&gt;s is FT*******, F**T***** or F***T****.
229:       *
230:       *@param  other  the &lt;code&gt;Geometry&lt;/code&gt; with which to compare this &lt;code&gt;Geometry&lt;/code&gt;
231:       *@return        &lt;code&gt;true&lt;/code&gt; if the two &lt;code&gt;Geometry&lt;/code&gt;s touch;
232:       *      Returns false if both &lt;code&gt;Geometry&lt;/code&gt;s are points
233:       */
234:      boolean touches(Geometry other);
235:    
236:      /**
237:       *  Returns &lt;code&gt;true&lt;/code&gt; if the DE-9IM intersection matrix for the two
238:       *  &lt;code&gt;Geometry&lt;/code&gt;s is
239:       *  &lt;UL&gt;
240:       *    &lt;LI&gt; T*T****** (for a point and a curve, a point and an area or a line
241:       *    and an area)
242:       *    &lt;LI&gt; 0******** (for two curves)
243:       *  &lt;/UL&gt;
244:       *  .
245:       *
246:       *@param  other  the &lt;code&gt;Geometry&lt;/code&gt; with which to compare this &lt;code&gt;Geometry&lt;/code&gt;
247:       *@return        &lt;code&gt;true&lt;/code&gt; if the two &lt;code&gt;Geometry&lt;/code&gt;s cross.
248:       *      For this function to return &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;Geometry&lt;/code&gt;
249:       *      s must be a point and a curve; a point and a surface; two curves; or a
250:       *      curve and a surface.
251:       */
252:      boolean crosses(Geometry other);
253:    
254:      /**
255:       *  Returns &lt;code&gt;true&lt;/code&gt; if the DE-9IM intersection matrix for the two
256:       *  &lt;code&gt;Geometry&lt;/code&gt;s is T*F**F***.
257:       *
258:       *@param  other  the &lt;code&gt;Geometry&lt;/code&gt; with which to compare this &lt;code&gt;Geometry&lt;/code&gt;
259:       *@return        &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Geometry&lt;/code&gt; is within
260:       *      &lt;code&gt;other&lt;/code&gt;
261:       */
262:      boolean within(Geometry other);
263:    
264:      /**
265:       *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;other.within(this)&lt;/code&gt; returns
266:       *  &lt;code&gt;true&lt;/code&gt;.
267:       *
268:       *@param  other  the &lt;code&gt;Geometry&lt;/code&gt; with which to compare this &lt;code&gt;Geometry&lt;/code&gt;
269:       *@return        &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Geometry&lt;/code&gt; contains
270:       *      &lt;code&gt;other&lt;/code&gt;
271:       */
272:      boolean contains(Geometry other);
273:    
274:      /**
275:       *  Returns &lt;code&gt;true&lt;/code&gt; if the DE-9IM intersection matrix for the two
276:       *  &lt;code&gt;Geometry&lt;/code&gt;s is
277:       *  &lt;UL&gt;
278:       *    &lt;LI&gt; T*T***T** (for two points or two surfaces)
279:       *    &lt;LI&gt; 1*T***T** (for two curves)
280:       *  &lt;/UL&gt;
281:       *  .
282:       *
283:       *@param  other  the &lt;code&gt;Geometry&lt;/code&gt; with which to compare this &lt;code&gt;Geometry&lt;/code&gt;
284:       *@return        &lt;code&gt;true&lt;/code&gt; if the two &lt;code&gt;Geometry&lt;/code&gt;s overlap.
285:       *      For this function to return &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;Geometry&lt;/code&gt;
286:       *      s must be two points, two curves or two surfaces.
287:       */
288:      boolean overlaps(Geometry other);
289:    
290:      /**
291:       *  Returns &lt;code&gt;true&lt;/code&gt; if the elements in the DE-9IM intersection
292:       *  matrix for the two &lt;code&gt;Geometry&lt;/code&gt;s match the elements in &lt;code&gt;intersectionPattern&lt;/code&gt;
293:       *  , which may be:
294:       *  &lt;UL&gt;
295:       *    &lt;LI&gt; 0
296:       *    &lt;LI&gt; 1
297:       *    &lt;LI&gt; 2
298:       *    &lt;LI&gt; T ( = 0, 1 or 2)
299:       *    &lt;LI&gt; F ( = -1)
300:       *    &lt;LI&gt; * ( = -1, 0, 1 or 2)
301:       *  &lt;/UL&gt;
302:       *  For more information on the DE-9IM, see the OpenGIS Simple Features
303:       *  Specification.
304:       *
305:       *@param  other                the &lt;code&gt;Geometry&lt;/code&gt; with which to compare
306:       *      this &lt;code&gt;Geometry&lt;/code&gt;
307:       *@param  intersectionPattern  the pattern against which to check the
308:       *      intersection matrix for the two &lt;code&gt;Geometry&lt;/code&gt;s
309:       *@return                      &lt;code&gt;true&lt;/code&gt; if the DE-9IM intersection
310:       *      matrix for the two &lt;code&gt;Geometry&lt;/code&gt;s match &lt;code&gt;intersectionPattern&lt;/code&gt;
311:       */
312:      boolean relate(Geometry other, String intersectionPattern);
313:    
314:      /**
315:       *  Returns the DE-9IM intersection matrix for the two &lt;code&gt;Geometry&lt;/code&gt;s.
316:       *
317:       *@param  other  the &lt;code&gt;Geometry&lt;/code&gt; with which to compare this &lt;code&gt;Geometry&lt;/code&gt;
318:       *@return        a matrix describing the intersections of the interiors,
319:       *      boundaries and exteriors of the two &lt;code&gt;Geometry&lt;/code&gt;s
320:       */
321:      IntersectionMatrix relate(Geometry other);
322:    
323:      /**
324:       *  Returns a buffer region around this &lt;code&gt;Geometry&lt;/code&gt; having the given
325:       *  width.
326:       *
327:       *@param  distance  the width of the buffer, interpreted according to the
328:       *      &lt;code&gt;PrecisionModel&lt;/code&gt; of the &lt;code&gt;Geometry&lt;/code&gt;
329:       *@return           all points whose distance from this &lt;code&gt;Geometry&lt;/code&gt;
330:       *      are less than or equal to &lt;code&gt;distance&lt;/code&gt;
331:       */
332:      Geometry buffer(double distance);
333:    
334:      /**
335:       *  Returns the smallest convex &lt;code&gt;Polygon&lt;/code&gt; that contains all the
336:       *  points in the &lt;code&gt;Geometry&lt;/code&gt;. This obviously applies only to &lt;code&gt;Geometry&lt;/code&gt;
337:       *  s which contain 3 or more points; the results for degenerate cases are
338:       *  specified as follows:
339:       *  &lt;TABLE&gt;
340:       *
341:       *    &lt;TR&gt;
342:       *
343:       *      &lt;TH&gt;
344:       *        Number of &lt;code&gt;Point&lt;/code&gt;s in argument &lt;code&gt;Geometry&lt;/code&gt;
345:       *
346:       *      &lt;/TH&gt;
347:       *
348:       *      &lt;TH&gt;
349:       *        &lt;code&gt;Geometry&lt;/code&gt; class of result
350:       *      &lt;/TH&gt;
351:       *
352:       *    &lt;/TR&gt;
353:       *
354:       *    &lt;TR&gt;
355:       *
356:       *      &lt;TD&gt;
357:       *        0
358:       *      &lt;/TD&gt;
359:       *
360:       *      &lt;TD&gt;
361:       *        empty &lt;code&gt;GeometryCollection&lt;/code&gt;
362:       *      &lt;/TD&gt;
363:       *
364:       *    &lt;/TR&gt;
365:       *
366:       *    &lt;TR&gt;
367:       *
368:       *      &lt;TD&gt;
369:       *        1
370:       *      &lt;/TD&gt;
371:       *
372:       *      &lt;TD&gt;
373:       *        &lt;code&gt;Point&lt;/code&gt;
374:       *      &lt;/TD&gt;
375:       *
376:       *    &lt;/TR&gt;
377:       *
378:       *    &lt;TR&gt;
379:       *
380:       *      &lt;TD&gt;
381:       *        2
382:       *      &lt;/TD&gt;
383:       *
384:       *      &lt;TD&gt;
385:       *        &lt;code&gt;LineString&lt;/code&gt;
386:       *      &lt;/TD&gt;
387:       *
388:       *    &lt;/TR&gt;
389:       *
390:       *    &lt;TR&gt;
391:       *
392:       *      &lt;TD&gt;
393:       *        3 or more
394:       *      &lt;/TD&gt;
395:       *
396:       *      &lt;TD&gt;
397:       *        &lt;code&gt;Polygon&lt;/code&gt;
398:       *      &lt;/TD&gt;
399:       *
400:       *    &lt;/TR&gt;
401:       *
402:       *  &lt;/TABLE&gt;
403:       *
404:       *
405:       *@return    the minimum-area convex polygon containing this &lt;code&gt;Geometry&lt;/code&gt;'
406:       *      s points
407:       */
408:      Geometry convexHull();
409:    
410:      /**
411:       *  Returns a &lt;code&gt;Geometry&lt;/code&gt; representing the points shared by this
412:       *  &lt;code&gt;Geometry&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.
413:       *
414:       *@param  other  the &lt;code&gt;Geometry&lt;/code&gt; with which to compute the
415:       *      intersection
416:       *@return        the points common to the two &lt;code&gt;Geometry&lt;/code&gt;s
417:       */
418:      Geometry intersection(Geometry other);
419:    
420:      /**
421:       *  Returns a &lt;code&gt;Geometry&lt;/code&gt; representing all the points in this &lt;code&gt;Geometry&lt;/code&gt;
422:       *  and &lt;code&gt;other&lt;/code&gt;.
423:       *
424:       *@param  other  the &lt;code&gt;Geometry&lt;/code&gt; with which to compute the union
425:       *@return        a set combining the points of this &lt;code&gt;Geometry&lt;/code&gt; and
426:       *      the points of &lt;code&gt;other&lt;/code&gt;
427:       */
428:      Geometry union(Geometry other);
429:    
430:      /**
431:       *  Returns a &lt;code&gt;Geometry&lt;/code&gt; representing the points making up this
432:       *  &lt;code&gt;Geometry&lt;/code&gt; that do not make up &lt;code&gt;other&lt;/code&gt;. This method
433:       *  returns the closure of the resultant &lt;code&gt;Geometry&lt;/code&gt;.
434:       *
435:       *@param  other  the &lt;code&gt;Geometry&lt;/code&gt; with which to compute the
436:       *      difference
437:       *@return        the point set difference of this &lt;code&gt;Geometry&lt;/code&gt; with
438:       *      &lt;code&gt;other&lt;/code&gt;
439:       */
440:      Geometry difference(Geometry other);
441:    
442:      /**
443:       *  Returns a set combining the points in this &lt;code&gt;Geometry&lt;/code&gt; not in
444:       *  &lt;code&gt;other&lt;/code&gt;, and the points in &lt;code&gt;other&lt;/code&gt; not in this
445:       *  &lt;code&gt;Geometry&lt;/code&gt;. This method returns the closure of the resultant
446:       *  &lt;code&gt;Geometry&lt;/code&gt;.
447:       *
448:       *@param  other  the &lt;code&gt;Geometry&lt;/code&gt; with which to compute the symmetric
449:       *      difference
450:       *@return        the point set symmetric difference of this &lt;code&gt;Geometry&lt;/code&gt;
451:       *      with &lt;code&gt;other&lt;/code&gt;
452:       */
453:      Geometry symDifference(Geometry other);
454:    
455:      /**
456:       *  Returns the Well-known Text representation of this &lt;code&gt;Geometry&lt;/code&gt;.
457:       *  For a definition of the Well-known Text format, see the OpenGIS Simple
458:       *  Features Specification.
459:       *
460:       *@return    the Well-known Text representation of this &lt;code&gt;Geometry&lt;/code&gt;
461:       */
462:      String toText();
463:    }
464:    
</pre>
</body>
<SCRIPT LANGUAGE="JavaScript" TYPE="text/javascript">
<!--
var newWind;
function putJumpCode(){
	var cnt = 4;
	newWind.document.write('<html>\n');
	newWind.document.write('<title>HtmlDiff Navigation</title>\n');
	newWind.document.write('<body>\n');
	newWind.document.write('<form name="jump">\n');
	newWind.document.write('<input type="button" value=" |&lt; " name="First" onclick=goto_first(this.form)>&nbsp;')
	newWind.document.write('<input type="button" value=" &lt; " name="Prev" onclick=goto_prev(this.form)>&nbsp;&nbsp;\n');
	newWind.document.write('<select name=url onchange=menu_goto(this.form)> \n');
	for (var i=0; i<cnt ;i++ ) {
		newWind.document.write('<option value="#C'+i+'">Change #'+(i+1)+ '</option> \n');
		}
	newWind.document.write('');
	newWind.document.write('</select>&nbsp;&nbsp;\n');
	newWind.document.write('<input type="button" value=" &gt; " name="Next"\n');
	newWind.document.write('onclick=goto_next(this.form)>\n');
	newWind.document.write('<input type="button" value=" &gt| " name="Last"\n');
	newWind.document.write('onclick=goto_last(this.form)>\n');
	newWind.document.write('</form>\n');
	newWind.document.write('');
	newWind.document.write('<form method="POST">\n');
	newWind.document.write('<p align="center"><i><font size="3">Generated\n');
	newWind.document.write('by <a href="http://www.ComponentSoftware.com/products/htmldiff" target="_blank">HtmlDiff</a> \n');
	newWind.document.write('</form>\n');
	newWind.document.write('</body>\n');
	newWind.document.write('</html>\n');
	newWind.document.write('<SCRIPT LANGUAGE="JavaScript" TYPE="text/javascript">\n');
	newWind.document.write('<!--\n');
	newWind.document.write('');
	newWind.document.write('var directCloseFlag=1;\n');
	newWind.document.write('');
	newWind.document.write('function menu_goto( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('  var baseurl = opener.location.href ;\n');
	newWind.document.write('  var idx = baseurl.indexOf("#");\n');
	newWind.document.write('  if (idx > -1) {\n');
	newWind.document.write('	baseurl = baseurl.slice(0, idx);\n');
	newWind.document.write('  }');
	newWind.document.write('  selecteditem = menuform.url.selectedIndex ;\n');
	newWind.document.write('  newurl = menuform.url.options[ selecteditem ].value ;\n');
	newWind.document.write('  if (newurl.length != 0) {\n');
	newWind.document.write('    	opener.top.location.href = baseurl + newurl ;\n');
	newWind.document.write('  }');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_prev( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	if(menuform.url.selectedIndex>0) menuform.url.selectedIndex--;\n');
	newWind.document.write('	menu_goto( menuform )\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_first( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	menuform.url.selectedIndex = 0;	\n');
	newWind.document.write('	menu_goto( menuform );\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_last( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	menuform.url.selectedIndex = menuform.url.options.length-1;	\n');
	newWind.document.write('	menu_goto( menuform );\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_next( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	if(menuform.url.options.length > (menuform.url.selectedIndex+1))\n');
	newWind.document.write('	menuform.url.selectedIndex++;\n');
	newWind.document.write('	menu_goto( menuform )\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function restore()\n');
	newWind.document.write('{\n');
	newWind.document.write('    	focus();\n');
	newWind.document.write('	menu_goto(jump);\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('goto_first(jump)\n');
	newWind.document.write('//-->\n');
	newWind.document.write('<');
	newWind.document.write('/SCRIPT>\n');
}
function pop_navigate(){
  if ((newWind==null)||(newWind.closed)) {
    newWind =  window.open("" ,"HtmlDiffJumpWindow","width=270,height=40")
    if (newWind.opener == null) { // for Nav 2.0x
      newWind.opener = self // this creates and sets a new prop
    }	putJumpCode();
  
} 
else 
{	newWind.execScript("restore()", "JavaScript");
  }
}
function exit(){
  if (newWind != null) {   
	newWind.close();
  }
}
//--></SCRIPT></html>
