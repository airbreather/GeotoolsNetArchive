<body onunload=exit()><form method="POST">  <p align="center"><i><font size="3">Difference Analysis Generated by   <a href="http://www.ComponentSoftware.com/products/htmldiff" target="_blank">HtmlDiff</a> on  6/3/2003 11:47 AM</font></i>&nbsp;&nbsp;
  <input type="button" value="Navigate Changes" name="Navigate" onclick=pop_navigate()></p></form></body> <p align="left"><font size="4"><b>Base file: C:\Development\jts1.2\src\com\vividsolutions\jts\geom\PrecisionModel.java</b></font></p> <p align="left"><font size="4"><b>Modified file: C:\Development\jts1.3\src\com\vividsolutions\jts\geom\PrecisionModel.java</b></font></p><html>
<style type="text/css">
<!--
.HDNormal {  color: #000000;background:  #ffffff;text-decoration:none}
.HDDeleted {  color: #ff0000;background:  #ffffff;text-decoration:line-through}
.HDAdded {  color: #000000;background:  #ffff00;text-decoration:none}
-->
</style>
<body class="HDNormal">
<pre>1:  /*
2:   * <a name="diff" id="c0"><span class="HDDeleted"> </span></a>The <span class="HDDeleted">Java </span><span class="HDAdded">JTS </span>Topology Suite<span class="HDDeleted"> (JTS)</span> is a collection of Java classes that
3:   *  implement the fundamental operations required to validate a given
4:   *  geo-spatial data set to a known topological specification.
5:   *
6:   *  Copyright (C) 2001 Vivid Solutions
7:   *
8:   *  This library is free software; you can redistribute it and/or
9:   *  modify it under the terms of the GNU Lesser General Public
10:  *  License as published by the Free Software Foundation; either
11:  *  version 2.1 of the License, or (at your option) any later version.
12:  *
13:  *  This library is distributed in the hope that it will be useful,
14:  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
15:  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
16:  *  Lesser General Public License for more details.
17:  *
18:  *  You should have received a copy of the GNU Lesser General Public
19:  *  License along with this library; if not, write to the Free Software
20:  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
21:  *
22:  *  For more information, contact:
23:  *
24:  *  Vivid Solutions
25:  *  Suite #1A
26:  *  2328 Government Street
27:  *  Victoria BC  V8T 5G5
28:  *  Canada
29:  *
30:  *  (250)385-6040
31:  *  www.vividsolutions.com
32:  */
33: package com.vividsolutions.jts.geom;
34: 
<a name="diff" id="c1"><span class="HDAdded">35: import java.io.Serializable;
</span></a>35: 
<a name="diff" id="c2"><span class="HDAdded">37: import com.vividsolutions.jts.util.Assert;
</span></a>36: /**
37:  *  Converts a coordinate to and from a "precise" coordinate; that is, one whose
38:  *  precision is known exactly. In other words, specifies the grid of allowable
39:  *  points for all &lt;code&gt;Geometry&lt;/code&gt;s. &lt;P&gt;
40:  *
41:  *  Vertices are assumed to be precise in JTS. That is, the coordinates of
42:  *  vertices are assumed to be rounded to the defined precision model. Input
43:  *  routines will be responsible for rounding coordinates to the precision model
44:  *  before creating JTS structures. Non-constructive internal operations will
45:  *  assume that coordinates are rounded to the precision model. &lt;P&gt;
46:  *
47:  *  JTS methods <a name="diff" id="c3"><span class="HDDeleted">will</span></a><span class="HDAdded">do</span> not handle inputs with different precision models. &lt;P&gt;
48:  *
49:  *  The Precision Model <a name="diff" id="c4"><span class="HDDeleted">will </span></a><span class="HDAdded">is </span>be specified by a scale factor<span class="HDDeleted"> and an offset point</span>.
50:  *  The scale factor specifies <span class="HDDeleted">how many JTS units represent one world unit</span><span class="HDAdded">the grid which numbers are rounded to</span>.
51:  *  World coordinates are mapped to JTS coordinates according to the following
52:  *  equations:
53:  *  &lt;UL&gt;
54:  *    &lt;LI&gt; jtsPt.x = <a name="diff" id="c5"><span class="HDDeleted">truncate( </span></a><span class="HDAdded">round( </span>(inputPt.x <span class="HDDeleted">- offset.x) </span>* scale )<span class="HDAdded"> / scale</span>
55:  *    &lt;LI&gt; jtsPt.y = <span class="HDDeleted">truncate( </span><span class="HDAdded">round( </span>(inputPt.y <span class="HDDeleted">- offset.y) </span>* scale )<span class="HDAdded"> / scale</span>
56:  *  &lt;/UL&gt;
<a name="diff" id="c6"><span class="HDDeleted">57: </span></a><span class="HDDeleted"> *  Scaled coordinates will be represented internally as integral
</span><span class="HDDeleted">58: </span><span class="HDDeleted"> *  double-precision values. This is known as the "precise internal
</span><span class="HDAdded">59: </span><span class="HDAdded"> *  Coordinates are be represented as double-precision values.
</span>60:  * <span class="HDDeleted"> representation". </span>Since Java uses the IEEE-394 floating point standard, this
61:  *  provides 53 bits of precision. (Thus the maximum precisely representable
62:  *  integer is 9,007,199,254,740,992).
63:  *
64:  *@version 1.<a name="diff" id="c7"><span class="HDDeleted">2</span></a><span class="HDAdded">3</span>
65:  */
66: public class PrecisionModel <a name="diff" id="c8"><span class="HDDeleted">{</span></a><span class="HDAdded">implements Serializable, Comparable</span>
<span class="HDAdded">67: </span><span class="HDAdded">{
</span>68:   /**
69:    * The types of Precision Model which could be implemented.
70:    * (Note that JTS does not necessarily support all of these.)
71:    */
72:    /**
73:     * Fixed Precision implies that coordinates have a fixed number of decimal places
74:     */
75:   public final static int FIXED     = 1;
76:   /**
77:    * Floating precision corresponds to the usual notion of floating-point representation.
78:    */
79:   public final static int FLOATING  = 2;
80: 
81:   /**
82:    *  The maximum precise value representable in a double. Since IEE754
83:    *  double-precision numbers allow 53 bits of mantissa, the value is equal to
84:    *  2^53 - 1.
85:    */
86:   public final static double maximumPreciseValue = 9007199254740992.0;
<a name="diff" id="c9"><span class="HDDeleted">87:   /**
88:    * This method "fixes" an ordinate value to
89:    * the PrecisionModel grid.
90:    */
91:   public static double makePrecise(double val)
92:   {
93:     return Math.rint(val);
94:     //return (val &gt;= 0.0) ? Math.floor(val) : - Math.floor(-val);
95:     /*
96:      * Other options:
97:      * - Math.floor(a + 0.5d);
98:      * - Math.floor(a);
99:      * -  (val &gt;= 0.0) ? Math.floor(val) : - Math.floor(-val);
100:         */
101:      }
</span></a>102:    
103:      /**
104:       * The type of PrecisionModel this represents.
105:       */
106:      private int modelType = 0;
107:      /**
108:       * Amount by which to multiply a coordinate after subtracting the offset,
109:       * to obtain a precise coordinate.
110:       * If scale is 0, this PrecisionModel represents a floating precision model.
111:       * Coordinates are left with the implicit precision of the
112:       * floating-point representation.
113:       */
114:      private double scale;
115:      /**
116:       *  Amount by which to subtract the x-coordinate before multiplying by the
117:       *  scale, to obtain a precise coordinate.<a name="diff" id="c10"><span class="HDAdded">  NO LONGER USED.</span></a>
118:       */
119:      private double offsetX;
120:      /**
121:       *  Amount by which to subtract the y-coordinate before multiplying by the
122:       *  scale, to obtain a precise coordinate.<a name="diff" id="c11"><span class="HDAdded">  NO LONGER USED.</span></a>
123:       */
124:      private double offsetY;
125:    
126:      /**
127:       *  Creates a &lt;code&gt;PrecisionModel&lt;/code&gt; that specifies Floating precision.
128:       *
129:       */
130:      public PrecisionModel() {
131:        // default is floating precision
132:        modelType = FLOATING;
133:      }
134:    
135:      /**
136:       *  Creates a &lt;code&gt;PrecisionModel&lt;/code&gt; that specifies Fixed precision.
137:       *  Fixed-precision coordinates are represented as precise internal coordinates,
138:       *  which are <a name="diff" id="c12"><span class="HDDeleted">integers stored in double-precision</span></a><span class="HDAdded">rounded to the grid defined by the scale factor</span>.
<span class="HDDeleted">139:    </span><span class="HDDeleted">   *  Input coordinates are transformed into precise internal coordinates
</span><span class="HDDeleted">140:    </span><span class="HDDeleted">   *  according to the given scale, x-offset and y-offset.
</span>141:       *
142:       *@param  scale    amount by which to multiply a coordinate after subtracting
143:       *      the offset, to obtain a precise coordinate
144:       *@param  offsetX  <a name="diff" id="c13"><span class="HDDeleted">amount by which to subtract the x-coordinate before</span></a><span class="HDAdded">not used.</span>
<span class="HDDeleted">145:    </span><span class="HDDeleted">   *      multiplying by the scale, to obtain a precise coordinate.
</span><span class="HDDeleted">146:    </span><span class="HDDeleted">   *@param  offsetY  amount by which to subtract the y-coordinate before
</span><span class="HDDeleted">147:    </span><span class="HDDeleted">   *      multiplying by the scale, to obtain a precise coordinate.
</span><span class="HDAdded">148:    </span><span class="HDAdded">   *@param  offsetY  not used.
</span><span class="HDAdded">149:    </span><span class="HDAdded">   *
</span><span class="HDAdded">150:    </span><span class="HDAdded">   * @deprecated
</span>151:       */
152:      public PrecisionModel(double scale, double offsetX, double offsetY) {
153:        modelType = FIXED;
<a name="diff" id="c14"><span class="HDDeleted">154:    </span></a><span class="HDDeleted">    this.scale = scale;
</span><span class="HDAdded">155:    </span><span class="HDAdded">    setScale(scale);
</span>156:        this.offsetX = offsetX;
157:        this.offsetY = offsetY;
158:      }
159:      /**
<a name="diff" id="c15"><span class="HDAdded">139:       *  Creates a &lt;code&gt;PrecisionModel&lt;/code&gt; that specifies Fixed precision.
140:       *  Fixed-precision coordinates are represented as precise internal coordinates,
141:       *  which are rounded to the grid defined by the scale factor.
142:       *
143:       *@param  scale    amount by which to multiply a coordinate after subtracting
144:       *      the offset, to obtain a precise coordinate
145:       */
146:      public PrecisionModel(double scale) {
147:        modelType = FIXED;
148:        setScale(scale);
149:        this.offsetX = 0;
150:        this.offsetY = 0;
151:      }
152:      /**
</span></a>160:       *  Copy constructor to create a new &lt;code&gt;PrecisionModel&lt;/code&gt;
161:       *  from an existing one.
162:       */
163:      public PrecisionModel(PrecisionModel pm) {
164:        modelType = pm.modelType;
165:        scale = pm.scale;
166:        offsetX = pm.offsetX;
167:        offsetY = pm.offsetY;
168:      }
169:    
170:    
171:      public boolean isFloating()
172:      {
173:        return modelType == FLOATING;
174:      }
175:      /**
176:       *  Returns the multiplying factor used to obtain a precise coordinate.
<a name="diff" id="c16"><span class="HDAdded">170:       * This method is private because PrecisionModel is intended to
171:       * be an immutable (value) type.
</span></a>177:       *
178:       *@return    the amount by which to multiply a coordinate after subtracting
179:       *      the offset
180:       */
181:      public double getScale() {
182:        return scale;
183:      }
184:    
185:      /**
<a name="diff" id="c17"><span class="HDAdded">181:       *  Sets the multiplying factor used to obtain a precise coordinate.
182:       * This method is private because PrecisionModel is intended to
183:       * be an immutable (value) type.
184:       *
185:       */
186:      private void setScale(double scale)
187:      {
188:        this.scale = Math.abs(scale);
189:      }
190:      /**
</span></a>186:       *  Returns the x-offset used to obtain a precise coordinate.
187:       *
188:       *@return    the amount by which to subtract the x-coordinate before
189:       *      multiplying by the scale
190:       */
191:      public double getOffsetX() {
192:        return offsetX;
193:      }
194:    
195:      /**
196:       *  Returns the y-offset used to obtain a precise coordinate.
197:       *
198:       *@return    the amount by which to subtract the y-coordinate before
199:       *      multiplying by the scale
200:       */
201:      public double getOffsetY() {
202:        return offsetY;
203:      }
204:    
205:      /**
206:       *  Sets &lt;code&gt;internal&lt;/code&gt; to the precise representation of &lt;code&gt;external&lt;/code&gt;<a name="diff" id="c18"><span class="HDAdded">.</span></a>
<span class="HDDeleted">207:    </span><span class="HDDeleted">   *  .
</span>208:       *
209:       * @param external the original coordinate
210:       * @param internal the coordinate whose values will be changed to the
211:       *                 precise representation of &lt;code&gt;external&lt;/code&gt;
<a name="diff" id="c19"><span class="HDAdded">216:       * @deprecated
</span></a>212:       */
213:      public void toInternal (Coordinate external, Coordinate internal) {
214:        if (isFloating()) {
215:          internal.x = external.x;
216:          internal.y = external.y;
217:        }
218:        else {
219:          internal.x = makePrecise(<a name="diff" id="c20"><span class="HDDeleted">(external.x - offsetX)*scale</span></a><span class="HDAdded">external.x</span>);
220:          internal.y = makePrecise(<span class="HDDeleted">(external.y - offsetY)*scale</span><span class="HDAdded">external.y</span>);
221:        }
222:        internal.z = external.z;
223:      }
224:    
225:      /**
226:       *  Returns the precise representation of &lt;code&gt;external&lt;/code&gt;.
227:       *
228:       *@param  external  the original coordinate
229:       *@return           the coordinate whose values will be changed to the precise
230:       *      representation of &lt;code&gt;external&lt;/code&gt;
<a name="diff" id="c21"><span class="HDAdded">236:       * @deprecated
</span></a>231:       */
232:      public Coordinate toInternal(Coordinate external) {
233:        Coordinate internal = new Coordinate();
234:        toInternal(external, internal);
235:        return internal;
236:      }
237:    
238:      /**
239:       *  Returns the external representation of &lt;code&gt;internal&lt;/code&gt;.
240:       *
241:       *@param  internal  the original coordinate
242:       *@return           the coordinate whose values will be changed to the
243:       *      external representation of &lt;code&gt;internal&lt;/code&gt;
<a name="diff" id="c22"><span class="HDAdded">250:       * @deprecated
</span></a>244:       */
245:      public Coordinate toExternal(Coordinate internal) {
246:        Coordinate external = new Coordinate();
247:        toExternal(internal, external);
248:        return external;
249:      }
250:    
251:      /**
252:       *  Sets &lt;code&gt;external&lt;/code&gt; to the external representation of &lt;code&gt;internal&lt;/code&gt;
253:       *  .
254:       *
255:       *@param  internal  the original coordinate
256:       *@param  external  the coordinate whose values will be changed to the
257:       *      external representation of &lt;code&gt;internal&lt;/code&gt;
<a name="diff" id="c23"><span class="HDAdded">265:       * @deprecated
</span></a>258:       */
259:      public void toExternal(Coordinate internal, Coordinate external) {
<a name="diff" id="c24"><span class="HDDeleted">260:        if (isFloating()) {
</span></a>261:          external.x = internal.x;
262:          external.y = internal.y;
263:        }
<a name="diff" id="c25"><span class="HDAdded">264:    </span></a><span class="HDAdded">
</span>265:      <span class="HDDeleted">  else {</span><span class="HDAdded">/**</span>
<span class="HDDeleted">266:    </span><span class="HDDeleted">      external.x = (internal.x / scale) + offsetX;
</span><span class="HDDeleted">267:    </span><span class="HDDeleted">      external.y = (internal.y / scale) + offsetY;
</span><span class="HDDeleted">268:    </span><span class="HDDeleted">    }
</span><span class="HDDeleted">269:    </span><span class="HDDeleted">    external.z = internal.z;
</span><span class="HDAdded">270:    </span><span class="HDAdded">   * Rounds an numeric value to the PrecisionModel grid.
</span><span class="HDAdded">271:    </span><span class="HDAdded">   */
</span><span class="HDAdded">272:    </span><span class="HDAdded">  public double makePrecise(double val)
</span><span class="HDAdded">273:    </span><span class="HDAdded">  {
</span><span class="HDAdded">274:    </span><span class="HDAdded">    return Math.rint(val * scale) / scale;
</span>275:      }
276:    
277:      /**
<a name="diff" id="c26"><span class="HDDeleted">278:    </span></a><span class="HDDeleted">   *  Sets &lt;code&gt;p1&lt;/code&gt; to the value of external point p0
</span><span class="HDDeleted">279:    </span><span class="HDDeleted">   *  rounded to this precision model.
</span><span class="HDDeleted">280:    </span><span class="HDDeleted">   *
</span><span class="HDDeleted">281:    </span><span class="HDDeleted">   *@param  p0  the original coordinate
</span><span class="HDDeleted">282:    </span><span class="HDDeleted">   *@param  p1  the coordinate whose values will be changed to the
</span><span class="HDDeleted">283:    </span><span class="HDDeleted">   *      external representation of &lt;code&gt;internal&lt;/code&gt;
</span><span class="HDAdded">284:    </span><span class="HDAdded">   * Rounds a Coordinate to the PrecisionModel grid.
</span>285:       */
286:      public void <a name="diff" id="c27"><span class="HDDeleted">round(</span></a><span class="HDAdded">makePrecise(</span>Coordinate <span class="HDDeleted">p0, Coordinate p1) {</span><span class="HDAdded">coord)</span>
<span class="HDDeleted">287:    </span><span class="HDDeleted">    toInternal(p0, p1);
</span><span class="HDDeleted">288:    </span><span class="HDDeleted">    toExternal(p1, p1);
</span><span class="HDAdded">289:    </span><span class="HDAdded">  {
</span><span class="HDAdded">290:    </span><span class="HDAdded">    if (modelType == FLOATING) return;
</span><span class="HDAdded">291:    </span><span class="HDAdded">    coord.x = makePrecise(coord.x);
</span><span class="HDAdded">292:    </span><span class="HDAdded">    coord.y = makePrecise(coord.y);
</span>293:      }
294:    
295:      public String toString()
296:      {
297:        String description;
298:        if (isFloating()) {
299:          description = "Floating";
300:        }
301:        else {
302:          description = "Fixed ( Scale = " + getScale();
303:          <a name="diff" id="c28"><span class="HDAdded">//</span></a>description += "   Offset: X = " + getOffsetX();
304:          <span class="HDAdded">//</span>description += ", Y = " + getOffsetY();
305:          description += " )";
306:        }
307:        return description;
308:      }
309:      public boolean equals(Object other) {
310:        if (! (other instanceof PrecisionModel)) {
311:          return false;
312:        }
313:        PrecisionModel otherPrecisionModel = (PrecisionModel) other;
314:        return modelType == otherPrecisionModel.modelType
315:            &amp;&amp; offsetX == otherPrecisionModel.offsetX
316:            &amp;&amp; offsetY == otherPrecisionModel.offsetY
317:            &amp;&amp; scale == otherPrecisionModel.scale;
<a name="diff" id="c29"><span class="HDAdded">313:      }
314:      /**
315:       *  Compares this {@link PrecisionModel} object with the specified object for order.
316:       * A PrecisionModel is greater than another if it provides greater precision.
317:       *
318:       *@param  o  the &lt;code&gt;PrecisionModel&lt;/code&gt; with which this &lt;code&gt;PrecisionModel&lt;/code&gt;
319:       *      is being compared
320:       *@return    a negative integer, zero, or a positive integer as this &lt;code&gt;PrecisionModel&lt;/code&gt;
321:       *      is less than, equal to, or greater than the specified &lt;code&gt;PrecisionModel&lt;/code&gt;
322:       */
323:      public int compareTo(Object o) {
324:        PrecisionModel other = (PrecisionModel) o;
325:    
326:        if (modelType == FLOATING &amp;&amp; other.modelType == FLOATING) return 0;
327:        if (modelType == FLOATING &amp;&amp; other.modelType != FLOATING) return 1;
328:        if (modelType != FLOATING &amp;&amp; other.modelType == FLOATING) return -1;
329:        if (modelType == FIXED &amp;&amp; other.modelType == FIXED) {
330:          if (scale &gt; other.scale)
331:            return 1;
332:          else if (scale &lt; other.scale)
333:            return -1;
334:          else
335:            return 0;
336:        }
337:        Assert.shouldNeverReachHere("Unknown Precision Model type encountered");
338:        return 0;
</span></a>318:      }
319:    }
320:    
321:    
</pre>
</body>
<SCRIPT LANGUAGE="JavaScript" TYPE="text/javascript">
<!--
var newWind;
function putJumpCode(){
	var cnt = 30;
	newWind.document.write('<html>\n');
	newWind.document.write('<title>HtmlDiff Navigation</title>\n');
	newWind.document.write('<body>\n');
	newWind.document.write('<form name="jump">\n');
	newWind.document.write('<input type="button" value=" |&lt; " name="First" onclick=goto_first(this.form)>&nbsp;')
	newWind.document.write('<input type="button" value=" &lt; " name="Prev" onclick=goto_prev(this.form)>&nbsp;&nbsp;\n');
	newWind.document.write('<select name=url onchange=menu_goto(this.form)> \n');
	for (var i=0; i<cnt ;i++ ) {
		newWind.document.write('<option value="#C'+i+'">Change #'+(i+1)+ '</option> \n');
		}
	newWind.document.write('');
	newWind.document.write('</select>&nbsp;&nbsp;\n');
	newWind.document.write('<input type="button" value=" &gt; " name="Next"\n');
	newWind.document.write('onclick=goto_next(this.form)>\n');
	newWind.document.write('<input type="button" value=" &gt| " name="Last"\n');
	newWind.document.write('onclick=goto_last(this.form)>\n');
	newWind.document.write('</form>\n');
	newWind.document.write('');
	newWind.document.write('<form method="POST">\n');
	newWind.document.write('<p align="center"><i><font size="3">Generated\n');
	newWind.document.write('by <a href="http://www.ComponentSoftware.com/products/htmldiff" target="_blank">HtmlDiff</a> \n');
	newWind.document.write('</form>\n');
	newWind.document.write('</body>\n');
	newWind.document.write('</html>\n');
	newWind.document.write('<SCRIPT LANGUAGE="JavaScript" TYPE="text/javascript">\n');
	newWind.document.write('<!--\n');
	newWind.document.write('');
	newWind.document.write('var directCloseFlag=1;\n');
	newWind.document.write('');
	newWind.document.write('function menu_goto( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('  var baseurl = opener.location.href ;\n');
	newWind.document.write('  var idx = baseurl.indexOf("#");\n');
	newWind.document.write('  if (idx > -1) {\n');
	newWind.document.write('	baseurl = baseurl.slice(0, idx);\n');
	newWind.document.write('  }');
	newWind.document.write('  selecteditem = menuform.url.selectedIndex ;\n');
	newWind.document.write('  newurl = menuform.url.options[ selecteditem ].value ;\n');
	newWind.document.write('  if (newurl.length != 0) {\n');
	newWind.document.write('    	opener.top.location.href = baseurl + newurl ;\n');
	newWind.document.write('  }');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_prev( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	if(menuform.url.selectedIndex>0) menuform.url.selectedIndex--;\n');
	newWind.document.write('	menu_goto( menuform )\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_first( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	menuform.url.selectedIndex = 0;	\n');
	newWind.document.write('	menu_goto( menuform );\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_last( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	menuform.url.selectedIndex = menuform.url.options.length-1;	\n');
	newWind.document.write('	menu_goto( menuform );\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function goto_next( menuform )\n');
	newWind.document.write('{\n');
	newWind.document.write('	if(menuform.url.options.length > (menuform.url.selectedIndex+1))\n');
	newWind.document.write('	menuform.url.selectedIndex++;\n');
	newWind.document.write('	menu_goto( menuform )\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('function restore()\n');
	newWind.document.write('{\n');
	newWind.document.write('    	focus();\n');
	newWind.document.write('	menu_goto(jump);\n');
	newWind.document.write('}');
	newWind.document.write('');
	newWind.document.write('goto_first(jump)\n');
	newWind.document.write('//-->\n');
	newWind.document.write('<');
	newWind.document.write('/SCRIPT>\n');
}
function pop_navigate(){
  if ((newWind==null)||(newWind.closed)) {
    newWind =  window.open("" ,"HtmlDiffJumpWindow","width=270,height=40")
    if (newWind.opener == null) { // for Nav 2.0x
      newWind.opener = self // this creates and sets a new prop
    }	putJumpCode();
  
} 
else 
{	newWind.execScript("restore()", "JavaScript");
  }
}
function exit(){
  if (newWind != null) {   
	newWind.close();
  }
}
//--></SCRIPT></html>
